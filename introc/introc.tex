\chapter{C Programming Language}

\epigraph{If you want to teach systems, don't drum up the programmers, sort the issues, and make PRs. Instead, teach them to yearn for the vast and endless C.}{Antoine de Saint-Exup\'{e}ry (With edits from Bhuvy)}

\gls{C} is the de-facto programming language to do serious system serious programming.
Why? Most kernels are written in largely in C.
The \gls{linux kernel} \cite{Love} and the XNU kernel \citet{xnukernel} of which Mac OS X is based off.
The Windows Kernel uses C++, but doing system programming on that is much harder on windows that UNIX for beginner system programmers.
Most of you have some experience with C++, but C is a different beast entirely.
You don't have nice abstractions like classes and RAII to clean up memory.
You are going to have to do that yourself.
C gives you much more of an opportunity to shoot yourself in the foot but lets you do things at a much finer grain level.

\section{History of C}

C was developed by Dennis Ritchie and Ken Thompson at Bell Labs back in 1973 \cite{Ritchie:1993:DCL:155360.155580}.
Back then, we had gems of programming languages like Fortran, ALGOL, and LISP.
The goal of C was two fold.
One, to target the most popular computers at the time like the PDP-7.
Two, try and remove some of the lower level constructs like managing registers, programming assembly for jumps and instead create a language that had the power to express programs procedurally (as opposed to mathematically like lisp) with more readable code all while still having the ability to interface with the operating system.
It sounded like a tough feat.
At first, it was only used internally at Bell Labs along with the UNIX operating system.

The first "real" standardization is with Brian Kernighan and Dennis Ritchie's book \cite{kernighan1988c}. It is still widely regarded today as the only \gls{portable} set of C instructions. The K\&R book is known as the de-facto standard for learning C.  There were different standards of C from ANSI to ISO after the Unix guides. The one that we will be mainly focusing on is the \gls{POSIX} C library. Now to get the elephant out of the room, the Linux kernel is not entirely POSIX compliant. Mostly, it is because they didn't want to pay the fee for compliance but also it doesn't want to be completely compliant with a bunch of different standards because then it has to ensue increasing development costs to maintain compliance.

Fast forward however many years, and we are at the current C standard put forth by ISO: C11.
Not all the code that we us in this class will be in this format.
We will aim to using C99 as the standard that most computers recognize.
We will talk about some off-hand features like \keyword{getline} because they are so widely used with the GNU-C library.
We'll begin by providing a decently comprehensive overview of the language with pairing facilities.

\section{Features}

\begin{itemize}
	\item Fast. There is ver little separating you and the system.
	\item Simple.
    C and its standard library pose a simple set of portable functions.
	\item Memory Management.
    C let's you manage your memory.
    This can also bite you if you have memory errors.
	\item It's Everywhere.
    Pretty much every computer that is not embedded has some way of interfacing with C.
    The standard library is also everywhere.
    C has stood the test of time as a popular language, and it doesn't look like it is going anywhere.
\end{itemize}

\section{Crash course intro to C}

The only way to start learning C is by starting with hello world. As per the original example that Kernighan and Ritchie proposed way back when, the hello world hasn't changed that much.

\begin{lstlisting}[language=C]
#include <stdio.h>
int main(void) {
    printf("Hello World\n");
    return 0;
}
\end{lstlisting}

\begin{enumerate}
	\item The \keyword{\#include} directive takes the file \keyword{stdio.h} (which stands for \textbf{st}an\textbf{d}ard \textbf{i}nput and \textbf{o}utput) located somewhere in your operating system, copies the text, and substitutes it where the \keyword{\#include} was.
	\item The \keyword{int main(void)} is a function declaration. The first word \keyword{int} tells the compiler what the return type of the function is. The part before the parens (\keyword{main}) is the function name. In C, no two functions can have the same name in a single compiled program, shared libraries are a different touchy subject. Then, what comes after is the parameter list. When we give the parameter list for regular functions \keyword{(void)} that means that the compiler should error if the function is called with any arguments. For regular functions having a declaration like \keyword{void func()} means that you are allowed to call the function like \keyword{func(1, 2, 3)} because there is no delimiter. In the case of \keyword{main}, it is a special function. There are many ways of declaring \keyword{main} but the ones that you will be familiar with are \keyword{int main(void)}, \keyword{int main()}, and \keyword{int main(int argc, char *argv[])}.
	\item \keyword{printf("Hello World\n");} is what we call a function call. \keyword{printf} is defined as a part of \keyword{stdio.h}. The function has been compiled and lives somewhere else on our machine. All we need to do is include the header and call the function with the appropriate parameters (a string literal \keyword{"Hello World\n"}). If you don't have the newline, the buffer will not be flushed. It is by convention that buffered IO is not flushed until a newline.
	\item \keyword{return 0;}. \keyword{main} has to return an integer. By convention, \keyword{return 0} means success and anything else means failure.
\end{enumerate}

\begin{verbatim}
$ gcc main.c -o main
$ ./main
Hello World
$
\end{verbatim}

\begin{enumerate}
	\item \keyword{gcc} is short for the GNU-Compiler-Collection which has a host of compilers ready for use. The compiler infers from the extension that you are trying to compile a .c file
	\item \keyword{./main} tells your shell to execute the program in the current directory called main. The program then prints out hello world
\end{enumerate}

\section{Preprocessor}

What is the preprocessor? Preprocessing is an operation that the compiler performs \textbf{before} actually compiling the program.
It is a copy and paste command.
Meaning the following substitution is performed.

\begin{lstlisting}[language=C]
#define MAX_LENGTH 10
char buffer[MAX_LENGTH]
// After
char buffer[10]
\end{lstlisting}

There are side effects to the preprocessor though.
One problem is that the preprocessor needs to be able to tokenize properly, meaning trying to redefine the internals of the C language with a preprocessor may be impossible.
Another problem is that they can't be nested infinitely -- there is an unbounded depth where they need to stop.
Macros are also just simple text substitutions.
For example, look at what can happen if we have a macro that performs an inline modification.

\begin{lstlisting}[language=C]
#define min(a,b) ((a)<(b) ? (a) : (b))
int main() {
  int x = 4;
  if(min(x++, 5)) printf("%d is six", x);
  return 0;
}
\end{lstlisting}

Macros are simple text substitution so the above example expands to \keyword{x++\ \textless{}\ 100\ ?\ x++\ :\ 100} (parenthesis omitted for clarity).
Now for this case, it is opaque what gets printed out but it will be 6.
Also consider the edge case when operator precedence comes into play.

\begin{lstlisting}[language=C]
#define min(a,b) a < b ? a : b
int x = 99;
int r = 10 + min(99, 100); // r is 100!
// This is what it is expanded to
int r = 10 + 99 < 100 ? 99 : 100
// Which means
int r = (10 + 99) < 100 ? 99 : 100
\end{lstlisting}

You can also have logical problems with the flexibility of certain parameters.
One common source of confusion is with static arrays and the \keyword{sizeof} operator.

\begin{lstlisting}[language=C]
#define ARRAY_LENGTH(A) (sizeof((A)) / sizeof((A)[0]))
int static_array[10]; // ARRAY_LENGTH(static_array) = 10
int* dynamic_array = malloc(10); // ARRAY_LENGTH(dynamic_array) = 2 or 1
\end{lstlisting}

What is wrong with the macro? Well, it works if we have a static array like the first array because \keyword{sizeof} a static array returns the number of bytes that array takes up, and dividing it by the \keyword{sizeof(an\_element)} would give you the number of entries.
But if we use a pointer to a piece of memory, taking the sizeof the pointer and dividing it by the size of the first entry won't always give us the size of the array.

\subsection{Extra: Includes and conditionals}

The other preprocessor include is the \keyword{\#include} directive and conditionals.
The include directive is explained by example.

\begin{lstlisting}[language=C]
// foo.h
int bar();
\end{lstlisting}

\begin{lstlisting}[language=C]
// foo.c unpreprocessed
#include "foo.h"
int bar() {
}
\end{lstlisting}

After preprocessing, the compiler sees this

\begin{lstlisting}[language=C]
// foo.c unpreprocessed
int bar();

int bar() {

}
\end{lstlisting}

The other thing we have is conditionals.
If a macro is defined or equal to zeros, that branch is not taken

\begin{lstlisting}[language=C]
int main() {
#ifdef __GNUC__
    return 1;
#else
    return 0;
#endif
}
\end{lstlisting}

Using \keyword{gcc} your compiler would see this

\begin{lstlisting}[language=C]
int main() {
    return 1;
}
\end{lstlisting}


Using \keyword{clang} your compiler would see this

\begin{lstlisting}[language=C]
int main() {
    return 0;
}
\end{lstlisting}

\section{Language Facilities}

\subsection{Keywords}

C has an assortment of keywords.
Here are some constructs that you should know briefly as of C99.

\begin{enumerate}
	\item \keyword{break} is a keyword that is used in case statements or looping statements. When used in a case statement, the program jumps to the end of the block.
	      \\
	      \begin{lstlisting}[language=C]
switch(1) {
  case 1: /* Goes to this switch */
    puts("1");
    break; /* Jumps to the end of the block */
  case 2: /* Ignores this program */
    puts("2");
    break;
} /* Continues here */
\end{lstlisting}
	      \\
	      In the context of a loop, it breaks out of the inner-most loop. The loop can be either a \keyword{for}, \keyword{while}, or \keyword{do-while} construct
	      \\
	      \begin{lstlisting}[language=C]
while(1) {
  while(2) {
    break; /* Breaks out of while(2) */
  } /* Jumps here */
  break; /* Breaks out of while(1) */
} /* Continues here */
\end{lstlisting}
	    \item \keyword{const} is a language level construct that tells the compiler that this data should not be modified.
        If one tries to change a const variable, the program will not even compile.
        \keyword{const} works a little differently when put before the type, the compiler flips the first type and const.
        Then the compiler uses a left associativity rule.
        Meaning that whatever is left of the pointer is constant.
        This is known as const-correctedness.
	      \\
	      \begin{lstlisting}[language=C]
const int i = 0; // Same as "int const i = 0"
char *str = ...; // Mutable pointer to a mutable string
const char *const_str = ...; // Mutable pointer to a constant string
char const *const_str2 = ...; // Same as above
const char *const const_ptr_str = ...;
// Constant pointer to a constant string
\end{lstlisting}

	      But, it is important to know that this is a compiler imposed restriction only.
        There are ways of getting around this and the program will run fine with defined behavior.
        In systems programming, the only type of memory that you can't write to is system write-protected memory.

	      \begin{lstlisting}[language=C]
const int i = 0; // Same as "int const i = 0"
(*((int *)&i)) = 1; // i == 1 now
const char *ptr = "hi";
*ptr = '\0'; // Will cause a Segmentation Violation
\end{lstlisting}

	    \item \keyword{continue} is a control flow statement that exists only in loop constructions.
        Continue will skip the rest of the loop body and set the program counter back to the start of the loop before.

	      \begin{lstlisting}[language=C]
int i = 10;
while(i--) {
  if(1) continue; /* This gets triggered */
  *((int *)NULL) = 0;
} /* Then reaches the end of the while loop */
\end{lstlisting}

	    \item \keyword{do \{\} while();} is another loop constructs.
        These loops execute the body and then check the condition at the bottom of the loop.
        If the condition is zero, the loop body is not executed and the rest of the program is executed.
        Otherwise, the loop body is executed.

	      \begin{lstlisting}[language=C]
int i = 1;
do {
  printf("%d\n", i--);
} while (i > 10) /* Only executed once */
\end{lstlisting}

	    \item \keyword{enum} is to declare an enumeration.
        An enumeration is a type that can take on many, finite values.
        If you have an enum and don't specify any numerics, the c compiler when generate a unique number for that enum (within the context of the current enum) and use that for comparisons.
        To declare an instance of an enum, you must say \keyword{enum <type> varname}.
        The added benefit to this is that C can type check these expressions to make sure that you are only comparing alike types.

	      \begin{lstlisting}[language=C]
enum day{ monday, tuesday, wednesday,
  thursday, friday, saturday, sunday};

void process_day(enum day foo) {
  switch(foo) {
    case monday:
      printf("Go home!\n"); break;
    // ...
  }
}
\end{lstlisting}

	      It is completely possible to assign enum values to either be different or the same.
        Just don't rely on the compiler for consistent numbering. If you are going to use this abstraction, try not to break it.

	      \begin{lstlisting}[language=C]
enum day{
  monday = 0,
  tuesday = 0,
  wednesday = 0,
  thursday = 1,
  friday = 10,
  saturday = 10,
  sunday = 0};

void process_day(enum day foo) {
  switch(foo) {
    case monday:
      printf("Go home!\n"); break;
    // ...
  }
}
\end{lstlisting}

	    \item \keyword{extern} is a special keyword that tells the compiler that the variable may be defined in another object file or a library, so the compiler doesn't throw an error when either the variable is not defined or if the variable is defined twice because the first file will really be referencing the variable in the other file.

	      \begin{lstlisting}[language=C]
// file1.c
extern int panic;

void foo() {
  if (panic) {
    printf("NONONONONO");
  } else {
    printf("This is fine");
  }
}

//file2.c

int panic = 1;
\end{lstlisting}

	    \item \keyword{for} is a keyword that allows you to iterate with an initialization condition, a loop invariant, and an update condition.
        This is meant to be a replacement for the while loop

	      \begin{lstlisting}[language=C]
for (initialization; check; update) {
  //...
}

// Typically
int i;
for (i = 0; i < 10; i++) {
  //...
}
\end{lstlisting}

	      As of the C89 standard, you cannot declare variables inside the \keyword{for} loop.
        This is because there was a disagreement in the standard for how the scoping rules of a variable defined in the loop would work.
        It has since been resolved with more recent standards, so people can use the for loop that they know and love today

	      \begin{lstlisting}[language=C]
for(int i = 0; i < 10; ++i) {

}
\end{lstlisting}

	      The order of evaluation for a \keyword{for} loop is as follows

	      \begin{enumerate}
		      \item Perform the initialization condition.
		      \item Check the invariant. If false, terminate the loop and execute the next statement. If true, continue to the body of the loop.
		      \item Perform the body of the loop.
		      \item Perform the update condition.
		      \item Jump to checking the invariant step.
	      \end{enumerate}

	    \item \keyword{goto} is a keyword that allows you to do conditional jumps.
        Do not use \keyword{goto} in your programs.
        The reason being is that it makes your code infinitely more hard to understand when strung together with multiple chains.
        It is fine to use in some contexts though.
        The keyword is usually used in kernel contexts when adding another stack frame for cleanup isn't a good idea.
        The canonical example of kernel cleanup is as below.

	      \begin{lstlisting}[language=C]
void setup(void) {
  Doe *deer;
  Ray *drop;
  Mi *myself;

  if (!setupdoe(deer)) {
    goto finish;
  }

  if (!setupray(drop)) {
    goto cleanupdoe;
  }

  if (!setupmi(myself)) {
    goto cleanupray;
  }

  perform_action(deer, drop, myself);

cleanupray:
  cleanup(drop);
cleanupdoe:
  cleanup(deer);
finish:
  return;
}
\end{lstlisting}
	    \item \keyword{if else else-if} are control flow keywords.
        There are a few ways to use these (1) A bare if (2) An if with an else (3) an if with an else-if (4) an if with an else if and else.
        The statements are always executed from the if to the else.
        If any of the intermediate conditions are true, the if block performs that action and goes to the end of that block.

	      \begin{lstlisting}[language=C]
// (1)

if (connect(...))
  return -1;

// (2)
if (connect(...)) {
  exit(-1);
} else {
  printf("Connected!");
}

// (3)
if (connect(...)) {
  exit(-1);
} else if (bind(..)) {
  exit(-2);
}

// (1)
if (connect(...)) {
  exit(-1);
} else if (bind(..)) {
  exit(-2);
} else {
  printf("Successfully bound!");
}
\end{lstlisting}

	    \item \keyword{inline} is a compiler keyword that tells the compiler it's okay not to create a new function in the assembly.
        Instead, the compile is hinted at substituting the function body directly into the calling function.
        This is not always recommended explicitly as the compiler is usually smart enough to know when to \keyword{inline} a function for you.

	      \begin{lstlisting}[language=C]
inline int max(int a, int b) {
  return a < b ? a : b;
}

int main() {
  printf("Max %d", max(a, b));
  // printf("Max %d", a < b ? a : b);
}
\end{lstlisting}

	    \item \keyword{restrict} is a keyword that tells the compiler that this particular memory region shouldn't overlap with all other memory regions.
        The use case for this is to tell users of the program that it is undefined behavior if the memory regions overlap.

	      \begin{lstlisting}[language=C]
memcpy(void * restrict dest, const void* restrict src, size_t bytes);

void add_array(int *a, int * restrict c) {
  *a += *c;
}
int *a = malloc(3*sizeof(*a));
*a = 1; *a = 2; *a = 3;
add_array(a + 1, a) // Well defined
add_array(a, a) // Undefined
\end{lstlisting}
	    \item \keyword{return} is a control flow operator that exits the current function.
        If the function is \keyword{void} then it simply exits the functions.
        Otherwise another parameter follows as the return value.

	      \begin{lstlisting}[language=C]
void process() {
  if (connect(...)) {
    return -1;
  } else if (bind(...)) {
    return -2
  }
  return 0;
}
\end{lstlisting}

	    \item \keyword{signed} is a modifier which is rarely used, but it forces an type to be signed instead of unsigned.
        The reason that this is so rarely used is because types are signed by default and need to have the \keyword{unsigned} modifier to make them unsigned but it may be useful in cases where you want the compiler to default a signed type like.

	      \begin{lstlisting}[language=C]
int count_bits_and_sign(signed representation) {
  //...
}
\end{lstlisting}
	    \item \keyword{sizeof} is an operator that is evaluated at compile time, which evaluates to the number of bytes that the expression contains.
        Meaning that when the compiler infers the type the following code changes.
	      \begin{lstlisting}[language=C]
char a = 0;
printf("%zu", sizeof(a++));
\end{lstlisting}

	      \begin{lstlisting}[language=C]
char a = 0;
printf("%zu", 1);
\end{lstlisting}

	      Which then the compiler is allowed to operate on further.
        A note that you must have a complete definition of the type at compile time or else you may get an odd error.
        Consider the following

	      \begin{lstlisting}[language=C]
// file.c
struct person;

printf("%zu", sizeof(person));

// file2.c

struct person {
  // Declarations
}
\end{lstlisting}

	      This code will not compile because sizeof is not able to compile \keyword{file.c} without knowing the full declaration of the \texttt{person} struct.
        That is typically why we either put the full declaration in a header file or we abstract the creation and the interaction away so that users cannot access the internals of our struct.
        Also, if the compiler knows the full length of an array object, it will use that in the expression instead of decaying it to a pointer.

	      \begin{lstlisting}[language=C]
char str1[] = "will be 11";
char* str2 = "will be 8";
sizeof(str1) //11 because it is an array
sizeof(str2) //8 because it is a pointer
\end{lstlisting}

	      Be careful, using sizeof for the length of a string!

	\item \keyword{static} is a type specifier with three meanings.

	      \begin{enumerate}
		      \item When used with a global variable or function declaration it means that the scope of the variable or the function is only limited to the file.
		      \item When used with a function variable, that declares that the variable has static allocation -- meaning that the variable is allocated once at program start up not every time the program is run.
	      \end{enumerate}

	      \begin{lstlisting}[language=C]
static int i = 0;

static int _perform_calculation(void) {
  // ...
}

char *print_time(void) {
  static char buffer[200]; // Shared every time a function is called
  // ...
}
\end{lstlisting}

	    \item \keyword{struct} is a keyword that allows you to pair multiple types together into a new structure.
        Structs are contiguous regions of memory that one can access specific elements of each memory as if they were separate variables.

	      \begin{lstlisting}[language=C]
struct hostname {
  const char *port;
  const char *name;
  const char *resource;
}; // You need the semicolon at the end
// Assign each individually
struct hostname facebook;
facebook.port = "80";
facebook.name = "www.google.com";
facebook.resource = "/";

// You can use static initialization in later versions of c
struct hostname google = {"80", "www.google.com", "/"};
\end{lstlisting}


	    \item \keyword{switch case default} Switches are essentially glorified jump statements.
        Meaning that you take either a byte or an integer and the control flow of the program jumps to that location.
	      \\
	      \begin{lstlisting}[language=C]
switch(/* char or int */) {
  case INT1: puts("1");
  case INT2: puts("2");
  case INT3: puts("3");
}
\end{lstlisting}

	      If we give a value of 2 then
	      \\
	      \begin{lstlisting}[language=C]
switch(2) {
  case 1: puts("1"); /* Doesn't run this */
  case 2: puts("2"); /* Runs this */
  case 3: puts("3"); /* Also runs this */
}
\end{lstlisting}

        One of the more famous examples of this is Duff's device which allows for loop unrolling. You don't need to understand this code for the purposes of this class, but it is fun to look at \cite{duff}.

        \begin{lstlisting}[language=C]
send(to, from, count)
register short *to, *from;
register count;
{
  register n=(count+7)/8;
  switch(count%8){
  case 0:	do{	*to = *from++;
  case 7:		*to = *from++;
  case 6:		*to = *from++;
  case 5:		*to = *from++;
  case 4:		*to = *from++;
  case 3:		*to = *from++;
  case 2:		*to = *from++;
  case 1:		*to = *from++;
    }while(--n>0);
  }
}
\end{lstlisting}
        This piece of code highlights that switch statements are just goto statements, and you can put whatever other valid piece of code on the other end of a switch case. Most of the time it doesn't make sense, some of the time it just makes too much sense.

	    \item \keyword{typedef} declares an alias for a type.
        Often used with structs to reduce the visual clutter of having to write `struct' as part of the type.

	      \begin{lstlisting}[language=C]
typedef float real;
real gravity = 10;
// Also typedef gives us an abstraction over the underlying type used.
// In the future, we only need to change this typedef if we
// wanted our physics library to use doubles instead of floats.

typedef struct link link_t;
//With structs, include the keyword 'struct' as part of the original types
\end{lstlisting}

	      In this class, we regularly typedef functions.
        A typedef for a function can be this for example

	      \begin{lstlisting}[language=C]
typedef int (*comparator)(void*,void*);

int greater_than(void* a, void* b){
    return a > b;
}
comparator gt = greater_than;
\end{lstlisting}

	      This declares a function type comparator that accepts two \keyword{void*} params and returns an integer.

	    \item \keyword{union} is a new type specifier.
        A union is one piece of memory that a bunch of variables occupy.
        It is used to maintain consistency while having the flexibility to switch between types without maintaining functions to keep track of the bits.
        Consider an example where we have different pixel values.
	      \begin{lstlisting}[language=C]
union pixel {
  struct values {
    char red;
    char blue;
    char green;
    char alpha;
  } values;
  uint32_t encoded;
}; // Ending semicolon needed
union pixel a;
// When modifying or reading
a.values.red;
a.values.blue = 0x0;

// When writing to a file
fprintf(picture, "%d", a.encoded);
\end{lstlisting}

	    \item \keyword{unsigned} is a type modifier that forces \keyword{unsigned} behavior in the variables they modify.
        Unsigned can only be on primitive int types (like \keyword{int} and \keyword{long}).
        There is a lot of behavior associated with unsigned arithmetic, just know for the most part unless you need to do bit shifting you probably won't need it.

	    \item \keyword{void} is a two folded keyword.
        When used in terms of function or parameter definition then it means that it returns no value or accepts no parameter specifically. The following declares a function that accepts no parameters and returns nothing.

	      \begin{lstlisting}[language=C]
void foo(void);
\end{lstlisting}


	      The other use of \keyword{void} is when you are defining.
        A \keyword{void *} pointer is just a memory address. It is specified as an incomplete type meaning that you cannot dereference it but it can be promoted to any time to any other type. Pointer arithmetic with these pointer is undefined behavior.

	      \begin{lstlisting}[langauge=C]
int *array = void_ptr; // No cast needed
\end{lstlisting}

	    \item \keyword{volatile} is a compiler keyword.
        This means that the compiler should not optimize its value out.
        Consider the following simple function.
	      \\
	      \begin{lstlisting}[language=C]
int flag = 1;
pass_flag(&flag);
while(flag) {
    // Do things unrelated to flag
}
\end{lstlisting}
	      \\
	      The compiler may, since the internals of the while loop have nothing to do with the flag, optimize it to the following even though a function may alter the data.
	      \\
	      \begin{lstlisting}[language=C]
while(1) {
    // Do things unrelated to flag
}
\end{lstlisting}
	      If you put the volatile keyword then it forces the compiler to keep the variable in and perform that check. This is particularly useful for cases where you are doing multi-process or multi-threaded programs so that we can
	\item \keyword{while } represents the traditional \keyword{while} loop. There is a condition at the top of the loop. While that condition evaluates to a non-zero value, the loop body will be run.
\end{enumerate}

\subsection{C data types}

There are many data types in c. All of them as you may realize are either an integer or a floating point number and different types are variations on that.

\begin{enumerate}
	\item \keyword{char} Represents exactly one byte of data. The number of bits in a byte might vary. \keyword{unsigned char} and \keyword{signed char} mean the exact same thing. This must be aligned on a boundary (meaning you cannot use bits in between two addresses). The rest of the types will assume 8 bits in a byte.
	\item \keyword{short (short int)} must be at least two bytes. This is aligned on a two byte boundary, meaning that the address must be divisible by two.
	\item \keyword{int} must be at least two bytes. Again aligned to a two byte boundary \cite[P. 34]{ISON1124}. On most machines this will be 4 bytes.
	\item \keyword{long (long int)} must be at least four bytes, which are aligned to a four byte boundary. On some machines this can be 8 bytes.
	\item \keyword{long long} must be at least eight bytes, aligned to an eight byte boundary.
	\item \keyword{float} represents an IEEE-754 single precision floating point number tightly specified by IEEE \cite{4610935}. This will be four bytes aligned to a four byte boundary on most machines.
	\item \keyword{double} represents an IEEE-754 double precision floating point number specified by the same standard, which is aligned to the nearest eight byte boundary.
\end{enumerate}

\subsection{Operators}

Operators are language constructs in C that are defined as part of the grammar of the language.

\begin{enumerate}
	\item \keyword{[]} is the subscript operator. \texttt{a[n] == (a + n)*} where \texttt{n} is a number type and \texttt{a} is a pointer type.
	\item \keyword{->} is the structure dereference operator. If you have a pointer to a struct \texttt{*p}, you can use this to access one of its elements. \texttt{p->element}.
	\item \keyword{.} is the structure reference operator. If you have an object on the stack \texttt{a} then you can access an element \texttt{a.element}.
	\item \keyword{+/-a} is the unary plus and minus operator. They either keep or negate the sign, respectively, of the integer or float type underneath.
	\item \keyword{*a} is the dereference operator. If you have a pointer  \texttt{*p}, you can use this to access the element located at this memory address. If you are reading, the return value will be the size of the underlying type. If you are writing, the value will be written with an offset.
	\item \keyword{\&a} is the addressof operator. This takes the an element and returns its address.
	\item \keyword{++} is the increment operator. You can either take it prefix or postfix, meaning that the variable that is being incremented can either be before or after the operator. \keyword{a = 0; ++a === 1} and \keyword{a = 1; a++ === 0}.
	\item \keyword{--} is the decrement operator. Same semantics as the increment operator except with decreasing the value by one.
	\item \keyword{sizeof} is the sizeof operator. This is also mentioned in the keywords section.
	\item \keyword{a <mop> b} where \keyword{<mop>=+, -, *, \%, /} are the mathematical binary operators. If the operands are both number types, then the operations are plus, minus, times, modulo, and division respectively. If the left operand is a pointer and the right operand is an integer type, then only plus or minus may be used and the rules for pointer arithmetic are invoked.
	\item \keyword{>>/<<} are the bit shift operators. The operand on the right has to be an integer type whose signedness is ignored unless it is signed negative in which case the behavior is undefined. The operator on the left decides a lot of semantics. If we are left shifting, there will always be zeros introduced on the right. If we are right shifting there are a few different cases
	      \begin{itemize}
		      \item If the operand on the left is signed, then the integer is sign extended. This means that if the number has the sign bit set, then any shift right will introduce ones on the left. If the number does not have the sign bit set, any shift right will introduce zeros on the left.
		      \item If the operand is unsigned, zeros will be introduced on the left either way.
	      \end{itemize}

	      \begin{lstlisting}[language=C]
unsigned short uns = -127; // 1111111110000001
short sig = 1; // 0000000000000001
uns << 2; // 1111111000000100
sig << 2; // 0000000000000100
uns >> 2; // 1111111111100000
sig >> 2; // 0000000000000000
\end{lstlisting}
	\item \keyword{<=/>=} are the greater than equal to/less than equal to operators. They do as the name implies.
	\item \keyword{</>} are the greater than/less than operators. They again do as the name implies.
	\item \keyword{==/\!=} are the equal/not equal to operators. They once again do as the name implies.
	\item \keyword{\&\&} is the logical and operator. If the first operand is zero, the second won't be evaluated and the expression will evaluate to 0. Otherwise, it yields a 1-0 value of the second operand.
	\item \keyword{||} is the logical or operator. If the first operand is not zero, then second won't be evaluated and the expression will evaluate to 1. Otherwise, it yields a 1-0 value of the second operand.
	\item \keyword{!} is the logical not operator. If the operand is zero, then this will return 1. Otherwise, it will return 0.
	\item \keyword{\&} If a bit is set in both operands, it is set in the output. Otherwise, it is not.
	\item \keyword{|} If a bit is set in either operand, it is set in the output. Otherwise, it is not.
	\item \keyword{~~} If a bit is set in the input, it will not be set in the output and vice versa.
	\item \keyword{?:} is the ternary operator. You put a boolean condition before the \? and if it evaluates to non-zero the element before the colon is returned otherwise the element after is. \keyword{1 ? a : b === a} and \keyword{0 ? a : b === b}.
	\item \keyword{a, b} is the comma operator. \keyword{a} is evaluated and then \keyword{b} is evaluated and \keyword{b} is returned.
\end{enumerate}

\section{The C and Linux}

So up until this point we've covered language fundamentals with C.
What starts diverging from all forms of C is the functions we use and how we interact with the operating system.
We'll now be focusing our attention to C and the POSIX variety of functions available to us.
We will talk about portable functions, for example \texttt{fwrite} \texttt{printf} etc etc, but we will be evaluating the internals and scrutinizing them under the POSIX models and more specifically LINUX. There are a number of things to that philosophy that makes the rest of this easier to know, so we'll put those things here.

\subsection{Everything is a File}

One POSIX mantra is that everything is a File.
Although that has become recently outdated, and moreover wrong, it is the convention we still use today.
What POSIX means is everything is a file is that everything is a file descriptor or an integer. For example, here is a file object, a network socket, and a kernel object

\begin{lstlisting}[language=C]
  int file_fd = open(...);
  int network_fd = socket(...);
  int kernel_fd = epoll_create1(...);
\end{lstlisting}

And operations on those objects are done through system calls.
One last thing to note before we move on is that the file descriptors are merely \textit{pointers}.
Imagine that each of the file descriptors in the example actually refer to an entry in a table of objects that the operating system picks and chooses from.
Objects can be allocated and deallocated, closed and opened, etc.
The program interacts with these objects by using the API or system calls specified

\subsection{System Calls}

Before we dive into common C functions, we need to know what a system call is.
If you are a student and completed HW0, feel free to gloss over this section.

A system call is an operation that the kernel carries out instead of the program.
The operating system prepares a system call then the kernel executes the system call to the best of its ability in kernel space.
In the previous example we opened up a file descriptor object.
We can now also write some bytes to the file descriptor object that represents a file and the oeprating system will do its best to get the bytes written to the disk.

\begin{lstlisting}[language=C]
write(file_fd, "Hello!", 6);
\end{lstlisting}

When we say the kernel tries its best, the operation could fail for a number of reasons. The file is no longer valid, the hard drive failed, the system was interrupted etc etc.
The way that you communicate with the outside system is with system calls though.
The other thing to note is that system calls are expensive.
Their cost in terms of time and CPU cycles has recently been decreased, but try to use them as sparingly as possible.

\subsection{C Calls}

Many C calls that we will discuss in the next sections will call some of the calls above in their linux implementation.
Their Windows implementation may be entirely different.
But we will be looking at one operating system in general.

\section{Common C Functions}

To find more information about any functions, use the man pages. Note the man pages are organized into sections. Section 2 are System calls. Section 3 are C libraries. On the web, Google \keyword{man 7 open}. In the shell, \keyword{man -S2 open} or \keyword{man -S3 printf}

\subsection{Input/Output}

In this section we will cover all the basic input and output functions in the standard library with references to system calls.
As a little bit of terminology, when your program is running on a terminal your Standard Output is your terminal and Standard Input is your terminal waiting for input.
There are other cases as you'll see later in this course of redirecting those to point to other things.
They are designated by the filedescriptors 0 and 1 respectively. 2 is reserved for standard error which by library convention is unbuffered.

\subsubsection{stdout oriented streams}

Standard output or stdout oriented streams are streams whose only options are to write to stdout.
\keyword{printf} is the function with which most people are familiar in this category.
The first parameter is a format string that includes placeholders for the data to be printed.
Common format specifiers are the following
\begin{enumerate}
\item \keyword{\%s} treat the argument as a c string pointer, keep printing all characters until the NULL-character is reached
\item \keyword{\%d} prints the argument as an integer
  \item \keyword{\%p} print the argument as a memory address.
    \end{enumerate}
By default, for performance, \keyword{printf} does not actually write anything out until its buffer is full or a newline is printed.
Here is an example of printing things out.

\begin{lstlisting}[language=C]
char *name = ... ; int score = ...;
printf("Hello %s, your result is %d\n", name, score);
printf("Debug: The string and int are stored at: %p and %p\n", name, &score );
// name already is a char pointer and points to the start of the array.
// We need "&" to get the address of the int variable
\end{lstlisting}

From the previous section,
\keyword{printf} calls the system call \keyword{write}.
\keyword{printf} includes an internal buffer so, to increase performance \keyword{printf} may not call \keyword{write} every time you call \keyword{printf}.
Another quirk of printf it is forced to call \keyword{write} on a newline character.
If one wants to \keyword{printf} to call write without a newline \keyword{fflush(\ FILE*\ inp\ )}.
Lastly, \keyword{printf} is a C library function.
\keyword{write} is a system call and as we know system calls are expensive. On the other hand, \keyword{printf} uses a buffer which suits our needs better at that point.
Meaning, don't over-optimize about using printf a lot even if system calls are expensive -- programs do it all the time.

To print strings and single characters use \keyword{puts(\ name\ )} and \keyword{putchar(\ c\ )} where name is a pointer to a C string and c is just a \keyword{char}

\begin{lstlisting}[language=C]
puts("Current selection: ");
putchar('1');
\end{lstlisting}

\subsubsection{Other streams}

To print to other file streams use \keyword{fprintf(\ \_file\_\ ,\ "Hello\ \%s,\ score:\ \%d",\ name,\ score);} Where \_file\_ is either predefined `stdout' `stderr' or a FILE pointer that was returned by \keyword{fopen} or \keyword{fdopen}.
You can also use file descriptors in the printf family of functions!
Just use \keyword{dprintf(int\ fd,\ char*\ format\_string,\ ...);}.
Just remember the stream may be buffered through internal buffering, so you will need to assure that the data is written to the file descriptor.

To print data into a C string, use \keyword{sprintf} or better \keyword{snprintf}.
\keyword{snprintf} returns the number of characters written excluding the terminating byte.
In the following, this would be a maximum of 199.
We would use \keyword{sprintf} in cases where we know that the size of the string will not be anything more than a certain fixed amount -- think about printing an integer, it will never be more than 11 characters with the null byte.

\begin{lstlisting}[language=C]
// Fixed
char int_string[20];
sprintf(int_string, "%d", integer);

// Variable length
char result[200];
int len = snprintf(result, sizeof(result), "%s:%d", name, score);
\end{lstlisting}

\subsection{stdin oriented functions}

Standard input or stdin oriented functions read from stdin directly.
Most of these functions have been deprecated due to them being poorly designed, as such we treat stdin as a file that we can read bytes from.
One of the most notorious offenders is \keyword{gets}.
\keyword{gets} is deprecated in C99 standard and has been removed from the latest C standard (C11).
The reason that it was deprecated was that there is no way to control for the length, so strings could get overrun very easily.

Programs should use \keyword{fgets} or \keyword{getline} instead.
Here is a quick example of reading at most 10 characters from stdin.

\begin{lstlisting}[language=C]
char *fgets (char *str, int num, FILE *stream);

ssize_t getline(char **lineptr, size_t *n, FILE *stream);

// Example, the following will not read more than 9 chars
char buffer[10];
char *result = fgets(buffer, sizeof(buffer), stdin);
\end{lstlisting}

The result is NULL if there was an error or the end of the file is reached.
Note, unlike \keyword{gets}, \keyword{fgets} copies the newline into the buffer, which you may want to discard.
On the other hand, one of the advantages of \keyword{getline} is that will automatically allocate and reallocate a buffer on the heap of sufficient size.

\begin{lstlisting}[language=C]
// ssize_t getline(char **lineptr, size_t *n, FILE *stream);

 /* set buffer and size to 0; they will be changed by getline */
char *buffer = NULL;
size_t size = 0;

ssize_t chars = getline(&buffer, &size, stdin);

// Discard newline character if it is present,
if (chars > 0 && buffer[chars-1] == '\n')
    buffer[chars-1] = '\0';

// Read another line.
// The existing buffer will be re-used, or, if necessary,
// It will be `free`'d and a new larger buffer will `malloc`'d
chars = getline(&buffer, &size, stdin);

// Later... don't forget to free the buffer!
free(buffer);
\end{lstlisting}

In addition to those functions, we have \keyword{perror} that has a two-fold meaning.
Let's say that you have a function call that just failed because you checked the man page, and it is a failing return code.
\keyword{perror(const\ char*\ message)} will print the English version of the error to stderr.

\begin{lstlisting}[language=C]
int main(){
    int ret = open("IDoNotExist.txt", O_RDONLY);
    if(ret < 0){
        perror("Opening IDoNotExist:");
    }
    //...
    return 0;
}
\end{lstlisting}

To have a library function parse input in addition to reading it, use \keyword{scanf} (or \keyword{fscanf} or \keyword{sscanf}) to get input from the default input stream, an arbitrary file stream or a C string respectively.
All of those functions will return how many items were parsed; it is a good idea to check if the number is equal to the amount expected.
Also naturally like \keyword{printf}, \keyword{scanf} functions require valid pointers. Instead of just pointing to valid memory, they need to also be writable.
It's a common source of error to pass in an incorrect pointer value.
For example,

\begin{lstlisting}[language=C]
int *data = malloc(sizeof(int));
char *line = "v 10";
char type;
// Good practice: Check scanf parsed the line and read two values:
int ok = 2 == sscanf(line, "%c %d", &type, &data); // pointer error
\end{lstlisting}

We wanted to write the character value into c and the integer value into the malloc'd memory.
However, we passed the address of the data pointer, not what the pointer is pointing to! So \keyword{sscanf} will change the pointer itself.
The pointer will now point to address 10 so this code will later fail when free(data) is called.

Now, scanf will just keep reading characters until the string ends.
To stop scanf from causing a buffer overflow, use a format specifier.
Make sure to pass one less than the size of the buffer.

\begin{lstlisting}[language=C]
char buffer[10];
scanf("%9s", buffer); // reads up to 9 characters from input (leave room for the 10th byte to be the terminating byte)
\end{lstlisting}

One last thing to note is if you thought system calls were expensive, the \keyword{scanf} family is much more expensive due to compatibility reasons. Imagine needing to take all of the printf specifiers correctly, the code isn't going to be very efficient.
Most of the time, if you are writing a standalone program, write the parser yourself.
If it is a one of program, feel free to use scanf.

\subsection{string.h}

String.h functions are a series of functions that deal with how to manipulate and check pieces of memory.
Most of them deal with C-Strings
A C-String is a series of bytes delimited by a NUL character which is eaul to the byte 0x00.
\href{https://linux.die.net/man/3/string}{More information about all of these functions}.
Any behavior not in the docs like passing \keyword{strlen(NULL)} is considered undefined behavior.

\begin{itemize}

	\item \keyword{int strlen(const char *s)} returns the length of the string not including the null byte

	\item \keyword{int strcmp(const char *s1, const char *s2)} returns an integer determining the lexicographic order of the strings. If s1 where to come before s2 in a dictionary, then a -1 is returned. If the two strings are equal, then 0. Else, 1.

	\item \keyword{char *strcpy(char *dest, const char *src)} Copies the string at \keyword{src} to \keyword{dest}. \textbf{assumes dest has enough space for src}

	\item \keyword{char *strcat(char *dest, const char *src)} Concatenates the string at \keyword{src} to the end of destination. \textbf{This function assumes that there is enough space for \keyword{src} at the end of destination including the NULL byte}

	\item \keyword{char *strdup(const char *dest)} Returns a \keyword{malloc}'d copy of the string.

	\item \keyword{char *strchr(const char *haystack, int needle)} Returns a pointer to the first occurrence of \keyword{needle} in the \keyword{haystack}. If none found, \keyword{NULL} is returned.

	\item \keyword{char *strstr(const char *haystack, const char *needle)} Same as above but this time a string!

	\item \keyword{char *strtok(const char *str, const char *delims)}

	  A dangerous but useful function strtok takes a string and tokenizes it.
    Meaning that it will transform the strings into separate strings.
    This function has a lot of specs so please read the man pages a contrived example is below.

	      \begin{lstlisting}[language=C]
#include <stdio.h>
#include <string.h>

int main(){
    char* upped = strdup("strtok,is,tricky,!!");
    char* start = strtok(upped, ",");
    do{
        printf("%s\n", start);
    }while((start = strtok(NULL, ",")));
    return 0;
}
\end{lstlisting}

	      \textbf{Output}

	      \begin{lstlisting}[language=console]
strtok
is
tricky
!!
\end{lstlisting}

	      Why is it tricky? Well what happens when I change \keyword{upped} like this?

	      \begin{lstlisting}[language=C]
char* upped = strdup("strtok,is,tricky,,,!!");
\end{lstlisting}

	\item For integer parsing use
	      \keyword{long int strtol(const char *nptr, char **endptr, int base);}
	      or
	      \keyword{long long int strtoll(const char *nptr, char **endptr, int base);}.

	      What these functions do is take the pointer to your string
	      \keyword{*nptr} and a \keyword{base} (ie binary, octal, decimal,
	      hexadecimal etc) and an optional pointer \keyword{endptr} and returns a
	      parsed value.

	      \begin{lstlisting}[language=C]
int main(){
    const char *nptr = "1A2436";
    char* endptr;
    long int result = strtol(nptr, &endptr, 16);
    return 0;
}
\end{lstlisting}

	      Be careful though! Error handling is tricky because the function won't return an error code.
        If you give it a string that is not a number it will return 0.
        This means you can't differentiate between a valid ``0'' and an invalid string.
        See the man page for more details on strol behavior with invalid and out of bounds values.
        A safer alternative is use to \keyword{sscanf} (and check the return value).

	      \begin{lstlisting}[language=C]
int main(){
    const char *input = "0"; // or "!##@" or ""
    char* endptr;
    long int parsed = strtol(input, &endptr, 10);
    if(parsed == 0){
        // Either the input string was not a valid base-10 number or it really was zero!

    }
    return 0;
}
\end{lstlisting}

	    \item \keyword{void *memcpy(void *dest, const void *src, size\_t n)} moves \keyword{n} bytes starting at \keyword{src} to \keyword{dest}.
        \textbf{Be careful}, there is undefined behavior when the memory regions overlap.
        This is one of the classic works on my machine examples because many times valgrind won't be able to pick it up because it will look like it works on your machine.
        When the autograder hits, fail.
        Consider the safer version below.

	    \item \keyword{void *memmove(void *dest, const void *src, size\_t n)} does the same thing as above, but if the memory regions overlap then it is guaranteed that all the bytes will get copied over correctly.
        \keyword{memcpy} and \keyword{memmove} both in \keyword{string.h}? Because strings are essentially raw memory with a null byte at the end of them!

\end{itemize}

\section{C Memory Model}

The C memory model is probably unlike most that you've seen before. Instead of allocating an object with type safety, we either use an automatic variable or request a sequence of bytes with \keyword{malloc} or another family member and later we \keyword{free} it.

\subsection{Structs}

In low-level terms, a struct is just a piece of contiguous memory, nothing more.
Just like an array, a struct has enough space to keep all of its members.
But unlike an array, it can store different types. Consider the contact struct declared above

\begin{lstlisting}[language=C]
struct contact {
    char firstname[20];
    char lastname[20];
    unsigned int phone;
};

struct contact bhuvan;
\end{lstlisting}

\begin{lstlisting}[language=C]
/* a lot of times we will do the following typdef
 so we can just write contact contact1 */

typedef struct contact contact;
contact bhuvan;

/* You can also declare the struct like this to get
 it done in one statement */
typedef struct optional_name {
    ...
} contact;
\end{lstlisting}

If you compile the code without any optimizations and reordering, you can expect the addresses of each of the variables to look like this.

\begin{lstlisting}[language=C]
&bhuvan           // 0x100
&bhuvan.firstname // 0x100 = 0x100+0x00
&bhuvan.lastname  // 0x114 = 0x100+0x14
&bhuvan.phone     // 0x128 = 0x100+0x28
\end{lstlisting}

Because all your compiler does is say `reserve this much space, and I will go and calculate the offsets of whatever variables you want to write to'. The offsets are where the variable starts at. The phone variables starts at the \keyword{0x128}th bytes and continues for sizeof(int) bytes, but not always. \textbf{Offsets don't determine where the variable ends though}. Consider the following hack that you see in a lot of kernel code.

\begin{lstlisting}[language=C]

typedef struct {
    int length;
    char c_str[0];
} string;

const char* to_convert = "bhuvan";
int length = strlen(to_convert);

// Let's convert to a c string
string* bhuvan_name;
bhuvan_name = malloc(sizeof(string) + length+1);
/*
Currently, our memory looks like this with junk in those black spaces
                ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
 bhuvan_name = |___|___|___|___|___|___|___|___|___|___|___|

*/


bhuvan_name->length = length;
/*
This writes the following values to the first four bytes
The rest is still garbage
                ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
 bhuvan_name = | 0 | 0 | 0 | 6 |___|___|___|___|___|___|___|

*/


strcpy(bhuvan_name->c_str, to_convert);
/*
Now our string is filled in correctly at the end of the struct

                ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ____
 bhuvan_name = | 0 | 0 | 0 | 6 | b | h | u | v | a | n | \0 |
                                                           ‾
*/

strcmp(bhuvan_name->c_str, "bhuvan") == 0 //The strings are equal!
\end{lstlisting}

What that zero length array does is point to the \textbf{end of the struct} this means that the compiler will leave room for all of the elements calculated with respect to their size on the operating system (ints, chars, etc). The zero length array will take up no bytes of space.
Since structs are just continuous pieces of memory, we can allocate \textbf{more} space than required and use the extra space as a place to store extra bytes.
Although this seems like a parlour trick, it is an important optimization because to have a variable length string any other way, one would need to have two different memory allocation calls.
This is highly inefficient for doing something as common in programming as string manipulation.

\subsubsection{Extra: Struct packing}

Structs may require something called \href{http://www.catb.org/esr/structure-packing/}{padding} (tutorial).
\textbf{We do not expect you to pack structs in this course, just know that it is there} This is because in the early days (and even now) when you have to an address from memory you have to do it in 32bit or 64bit blocks.
This also meant that you could only request addresses that were multiples of that.
Meaning that

\begin{lstlisting}[language=C]
struct picture{
    int height;
    pixel** data;
    int width;
    char* encoding;
}
\end{lstlisting}
You think picture looks like this. One box is four bytes

\begin{verbatim}
| h |  data | w | encod |
|---+-------+---+-------|
|___|___|___|___|___|___|
\end{verbatim}

With struct packing, would conceptually look like this

\begin{lstlisting}[language=C]
struct picture{
    int height;
    char slop1[4];
    pixel** data;
    int width;
    char slop2[4];
    char* encoding;
}
\end{lstlisting}

Here is some more ascii art for you

\begin{verbatim}
| h | ? | data  | w | ? | encod |
|---+---+-------+---+---+-------|
|___|___|___ ___|___|___|___ ___|
\end{verbatim}

This is on a 64-bit system. This is not always the case because
sometimes your processor supports unaligned accesses. What does this mean? Well there are two options you can set an attribute

\begin{lstlisting}[language=C]
struct __attribute__((packed, aligned(4))) picture{
    int height;
    pixel** data;
    int width;
    char* encoding;
}
\end{lstlisting}

\begin{verbatim}
| h |  data | w | encod |
|---+-------+---+-------|
|___|___|___|___|___|___|
\end{verbatim}

But now, every time I want to access \keyword{data} or \keyword{encoding},
I have to do two memory accesses.
The other thing you can do is reorder
the struct, although this is not always possible

\begin{lstlisting}[language=C]
struct picture{
    int height;
    int width;
    pixel** data;
    char* enconding;
}
\end{lstlisting}

\begin{verbatim}
| h | w | data  | encod |
|---+---+---+---+-------|
|___|___|___|___|___|___|
\end{verbatim}

\subsection{Strings in C}

In C we have
\href{https://en.wikipedia.org/wiki/Null-terminated_string}{Null
	Terminated} strings rather than
\href{https://en.wikipedia.org/wiki/String_(computer_science)\#Length-prefixed}{Length
	Prefixed} for historical reasons. What that means for your average everyday programming is that you need to remember the null character!
A string in C is defined as a bunch of bytes until you reach `\0' or the Nul Byte.

\subsection{Places for strings}

Whenever you define a constant string -- one in the form \keyword{char*\ str\ =\ "constant"} -- that string is stored in the \emph{data} depending on your architecture which is \textbf{read-only} meaning that any attempt to modify the string will cause a segfault.
One can also declare strings to be either in the writable data segment or the stack. To do so, just specify a length for the string or put brackets instead of a pointer \keyword{char str[] = "mutable"} and put in the global scope or the function scope for the data segment or the stack respectively.
If one, however, \keyword{malloc}'s space, one can change that string to be whatever they want.
Forgetting to NUL terminate a string is a big effect on the strings! Bounds checking is important.
The heartbleed bug mentioned earlier in the book is partially because of this.

Strings in C are represented as characters in memory.
The end of the string includes a NUL (0) byte.
So "ABC" requires four(4) bytes.
The only way to find out the length of a C string is to keep reading memory until you find the NULL byte.
C characters are always exactly one byte each.

\subsubsection{String constants are constant}

A string constant is naturally constant.
Any write will cause the operating system to produce a SEGFAULT.

\begin{lstlisting}[language=C]
char array[] = "Hi!"; // array contains a mutable copy
strcpy(array, "OK");

char *ptr = "Can't change me"; // ptr points to some immutable memory
strcpy(ptr, "Will not work");
\end{lstlisting}

String literals are character arrays stored in the code segment of the program, which is immutable.
Two string literals may share the same space in memory.
An example follows.

\begin{lstlisting}[language=C]
char *str1 = "Bhuvy likes books";
char *str2 = "Bhuvy likes books";
\end{lstlisting}

The strings pointed to by \keyword{str1} and \keyword{str2} may actually reside in the same location in memory.

Char arrays, however, contain the literal value which has been copied from the code segment into either the stack or static memory.
These following char arrays do not reside in the same place in memory.

\begin{lstlisting}[language=C]
char arr1[] = "Bhuvy also likes to write";
char arr2[] = "Bhuvy also likes to write";
\end{lstlisting}

Here are some common ways to initialize a string include. Where do they reside in memory?

\begin{lstlisting}[language=C]
char *str = "ABC";
char str[] = "ABC";
char str[]={'A','B','C','\0'};
\end{lstlisting}

\begin{lstlisting}[language=C]
char ary[] = "Hello";
char *ptr = "Hello";
\end{lstlisting}

We can also print out the pointer and the contents of a c string very easily. Here is some boilerplate code to do the printout.

\begin{lstlisting}[language=C]
char ary[] = "Hello";
char *ptr = "Hello";
// Print out address and contents
printf("%p : %s\n", ary, ary);
printf("%p : %s\n", ptr, ptr);
\end{lstlisting}

As mentioned before, the char array is mutable, so we can change its contents.
Be careful not to write bytes beyond the end of the array though.
Also again be careful not to get the two mixed up.

\begin{lstlisting}[language=C]
strcpy(ary, "World"); // OK
strcpy(ptr, "World"); // NOT OK - Segmentation fault (crashes)
\end{lstlisting}

We can, however, unlike the array, we change \keyword{ptr} to point to another piece of memory,

\begin{lstlisting}[language=C]
ptr = "World"; // OK!
ptr = ary; // OK!
ary = "World"; // NO won't compile
// ary is doomed to always refer to the original array.
printf("%p : %s\n", ptr, ptr);
strcpy(ptr, "World"); // OK because now ptr is pointing to mutable memory (the array)
\end{lstlisting}

What to take away from this is that pointers * can point to any type of memory while the char arrays mentioned earlier will always refer to the same piece of memory.
In a more common case, pointers will point to heap memory in which case the memory referred to by the pointer \textbf{can} be modified.

\section{Pointers}

Up until now, you may have not had a lot of work to do with pointers. Pointers are variables that hold addresses.
These addresses have numeric value, but usually we care about the contents underneath.
In this section, we will try to take your through a very basic introduction of pointers.

\subsection{Pointer Basics}

\subsubsection{Declaring a Pointer}

A pointer refers to a memory address. The type of the pointer is useful -- it tells the compiler how many bytes need to be read/written and what the semantics for addition are.

\begin{lstlisting}[language=C]
int *ptr1;
char *ptr2;
\end{lstlisting}

Due to C's grammar, an \keyword{int*} or any pointer is not actually its own type. You have to precede each pointer variable with an asterisk. As a common gotcha, the following

\begin{lstlisting}[language=C]
int* ptr3, ptr4;
\end{lstlisting}

Will only declare \keyword{*ptr3} as a pointer.
\keyword{ptr4} will actually be a regular int variable.
To fix this declaration, keep the \keyword{*} preceding to the pointer

\begin{lstlisting}[language=C]
int *ptr3, *ptr4;
\end{lstlisting}

Keep this in mind for structs as well.
If one does not typedef them, then the pointer goes after the type.

\begin{lstlisting}[language=C]
struct person *ptr3;
\end{lstlisting}

\subsubsection{Reading/Writing with pointers}

Let's say that we declare a pointer \keyword{int\ *ptr}. For the sake of discussion, let's say that \keyword{ptr} contains the memory address \keyword{0x1000}.
If we want to write to a pointer, we can dereference and assign \keyword{*ptr}.

\begin{lstlisting}[language=C]
*ptr = 0; // Writes some memory.
\end{lstlisting}

What C will do is take the type of the pointer which is an \keyword{int} and write \keyword{sizeof(int)} bytes from the start of the pointer, meaning that bytes \keyword{0x1000}, \keyword{0x1001}, \keyword{0x1002}, \keyword{0x1003} will all be zero.
The number of bytes written depends on the pointer type.
It is the same for all primitive types but structs are a little different.

Reading works roughly the same way, except you put the variable in the spot that it needs the value.

\begin{lstlisting}[language=C]
  int double = *ptr * 2
\end{lstlisting}

Reading and writing to non-primitive types gets a little tricky.
You can't assign a pointer to an integer, you need to have the same type.
In addition to that, the compilation unit -- usually the file or a header -- needs to have the size of the data structure readily available that means that opaque data structures can't be copied.
Here is an example of assigning a struct pointer

\begin{lstlisting}[language=C]
#include <stdio.h>

typedef struct {
    int a1;
    int a2;
} pair;

int main() {
    pair obj;
    pair zeros;
    zeros.a1 = 0;
    zeros.a2 = 0;
    pair *ptr = &obj;
    obj.a1 = 1;
    obj.a2 = 2;
    *ptr = zeros;
    printf("a1: %d, a2: %d\n", ptr->a1, ptr->a2);
    return 0;
}
\end{lstlisting}

As for reading structure pointers, don't do it directly.

\subsection{Pointer Arithmetic}

In addition to adding to an integer, you can add an integer to a pointer.
However, the pointer type is used to determine how much to increment the pointer.
For char pointers, this is trivial because characters are always one byte.

\begin{lstlisting}[language=C]
char *ptr = "Hello"; // ptr holds the memory location of 'H'
ptr += 2; //ptr now points to the first'l'
\end{lstlisting}

If an int is 4 bytes then ptr+1 points to 4 bytes after whatever ptr is pointing at.

\begin{lstlisting}[language=C]
char *ptr = "ABCDEFGH";
int *bna = (int *) ptr;
bna +=1; // Would cause iterate by one integer space (i.e 4 bytes on some systems)
ptr = (char *) bna;
printf("%s", ptr);
/* Notice how only 'EFGH' is printed. Why is that? Well as mentioned above, when performing 'bna+=1' we are increasing the **integer** pointer by 1, (translates to 4 bytes on most systems) which is equivalent to 4 characters (each character is only 1 byte)*/
return 0;
\end{lstlisting}

Because pointer arithmetic in C is always automatically scaled by the size of the type that is pointed to, you can't perform pointer
arithmetic on void pointers by POSIX standards though compilers will often treat the underlying type as \keyword{char}.
You can think of pointer arithmetic in C as essentially doing the
following

\begin{lstlisting}[language=C]
int *ptr1 = ...;
int *offset = ptr1 + 4;
\end{lstlisting}

Think

\begin{lstlisting}[language=C]
int *ptr1 = ...;
char *temp_ptr1 = (char*) ptr1;
int *offset = (int*)(temp_ptr1 + sizeof(int)*4);
\end{lstlisting}

To get the value. \textbf{Every time you do pointer arithmetic, take a deep breath and make sure that you are shifting over the number of bytes you think you are shifting over.}

\subsection{So what is a void pointer?}

A void pointer is a pointer without a type.
Void pointers are used when either a datatype you're dealing with is unknown or when you're interfacing C code with other programming languages.
You can think of this as a raw pointer, or just a memory address.
You cannot directly read or write to it because the void type does not have a size.
malloc by default returns a void pointer that can be safely promoted to any other type.

\begin{lstlisting}[language=C]
void *give_me_space = malloc(10);
char *string = give_me_space;
\end{lstlisting}

This does not require a cast because C automatically promotes \keyword{void*} to its appropriate type. \textbf{Note:}

\keyword{gcc} and \keyword{clang} are not total ISO-C compliant, meaning that they will let you do arithmetic on a void pointer.
They will treat it as a \keyword{char *} pointer.
Do not do this because it may not work with all compilers!

\section{Common Bugs}

\subsection{Null Bytes}

What's wrong with this code?

\begin{lstlisting}[language=C]
void mystrcpy(char*dest, char* src) {
  // void means no return value
  while( *src ) { dest = src; src ++; dest++; }
}
\end{lstlisting}

In the above code it simply changes the dest pointer to point to source string. Also the nuls bytes are not copied. Here's a better version -

\begin{lstlisting}[language=C]
  while( *src ) { *dest = *src; src ++; dest++; }
  *dest = *src;
\end{lstlisting}

Note it's also usual to see the following kind of implementation, which does everything inside the expression test, including copying the NUL byte.

\begin{lstlisting}[language=C]
  while( (*dest++ = *src++ )) {};
\end{lstlisting}

\subsection{Double Frees}

A double free error is when you accidentally attempt to free the same allocation twice.

\begin{lstlisting}[language=C]
int *p = malloc(sizeof(int));
free(p);

*p = 123; // Oops! - Dangling pointer! Writing to memory we don't own anymore

free(p); // Oops! - Double free!
\end{lstlisting}

The fix is first to write correct programs!
Secondly, it's good programming hygiene to reset pointers once the memory has been freed.
This ensures the pointer can't be used incorrectly without the program crashing.

\begin{lstlisting}[language=C]
p = NULL; // Now you can't use this pointer by mistake
\end{lstlisting}

\subsection{Returning pointers to automatic variables}

\begin{lstlisting}[language=C]
int *f() {
    int result = 42;
    static int imok;
    return &imok; // OK - static variables are not on the stack
    return &result; // Not OK
}
\end{lstlisting}

Automatic variables are bound to stack memory only for the lifetime of
the function. After the function returns it is an error to continue to
use the memory.

\subsection{Insufficient memory allocation}

\begin{lstlisting}[language=C]
struct User {
   char name[100];
};
typedef struct User user_t;

user_t *user = (user_t *) malloc(sizeof(user));
\end{lstlisting}

In the above example, we needed to allocate enough bytes for the struct.
Instead, we allocated enough bytes to hold a pointer.
Once we start using the user pointer we will corrupt memory.
The correct code is shown below.

\begin{lstlisting}[language=C]
struct User {
   char name[100];
};
typedef struct User user_t;

user_t * user = (user_t *) malloc(sizeof(user_t));
\end{lstlisting}

\subsection{Buffer overflow/ underflow}

Famous example: Heart Bleed performed a memcpy into a buffer that was of insufficient size.
Simple example: implement a strcpy and forget to add one to strlen, when determining the size of the memory required.

\begin{lstlisting}[language=C]
#define N (10)
int i = N, array[N];
for( ; i >= 0; i--) array[i] = i;
\end{lstlisting}

C does not check that pointers are valid. The above example writes into \keyword{array[10]} which is outside the array bounds. This can cause memory corruption because that memory location is probably being used for something else.
In practice, this can be harder to spot because the overflow/underflow may occur in a library call.
Here is our old friend gets.

\begin{lstlisting}[language=C]
gets(array); // Let's hope the input is shorter than my array!
\end{lstlisting}


\subsection{Strings require strlen(s)+1 bytes}

Every string must have a null byte after the last characters. To store
the string ``Hi'' it takes 3 bytes: [H] [i] [\backslash 0].

\begin{lstlisting}[language=C]
  char *strdup(const char *input) {  /* return a copy of 'input' */
    char *copy;
    copy = malloc(sizeof(char*));     /* nope! this allocates space for a pointer, not a string */
    copy = malloc(strlen(input));     /* Almost...but what about the null terminator? */
    copy = malloc(strlen(input) + 1); /* That's right. */
    strcpy(copy, input);   /* strcpy will provide the null terminator */
    return copy;
}
\end{lstlisting}

\subsection{Using uninitialized variables}

\begin{lstlisting}[language=C]
int myfunction() {
  int x;
  int y = x + 2;
...
\end{lstlisting}

Automatic variables hold garbage or bit pattern happened to be in memory or register.
It is an error to assume that it will always be initialized to zero.

\subsection{Assuming Uninitialized memory will be zeroed}

\begin{lstlisting}[language=C]
void myfunct() {
   char array[10];
   char *p = malloc(10);
\end{lstlisting}

Automatic (temporary variables) are not automatically initialized to zero.
Heap allocations using malloc are not automatically initialized to zero.

\section{Logic and Program flow mistakes}

These are a set of mistakes that may or may not make sense within the context of the program.

\subsection{Equal vs. Equality}

Confusingly in C the assignment operator also returns the assigned value. Most of the time it is ignored. We can use it to initialize multiple things on the same line.


\begin{lstlisting}[language=C]
  int p1, p2;
  p1 = p2 = 0;
\end{lstlisting}

More confusingly, if we forget an equals sign in the equality operator we will end up assigning that variable. Most of the time this isn't what we want to do.

\begin{lstlisting}[language=C]
int answer = 3; // Will print out the answer.
if (answer = 42) { printf("I've solved the answer! It's %d", answer);}
\end{lstlisting}

The quick way to fix that is to get in the habit of putting constants first.

\begin{lstlisting}[language=C]
if (42 = answer) { printf("I've solved the answer! It's %d", answer);}
\end{lstlisting}

There are cases where we want to do it. A common example is getline.

\begin{lstlisting}[language=C]
while ((nread = getline(&line, &len, stream)) != -1)
\end{lstlisting}

This piece of code calls getline, and assigns the return value or the number of bytes read to nread. It also in the same line checks if that value is -1 and if so terminates the loop.
It is always good practice to put parens around any assignment condition.

\subsection{Undeclared or incorrectly prototyped functions}

You may see code do something like this.

\begin{lstlisting}[language=C]
time_t start = time();
\end{lstlisting}

The system function `time' actually takes a parameter a pointer to some memory that can receive the time\_t structure or NULL.
The compiler did not catch this error because the programmer did not provide a valid function prototype by including \keyword{time.h}.

More confusingly this could compile, work for decades and then crash. The reason for that is that time would be found at link time, not compile time in the c standard library which almost surely is already in memory.
Since we aren't passing a parameter in, we are hoping the arguments on the stack (any garbage) is zeroed out because if it isn't, time will try to write the result of the function to that garbage which will cause the program to segfault.

\subsection{Extra Semicolons}

This is a pretty simple one, don't put semicolons when not needed.

\begin{lstlisting}[language=C]
for(int i = 0; i < 5; i++) ; printf("I'm printed once");
while(x < 10); x++ ; // X is never incremented
\end{lstlisting}

However, the following code is perfectly OK.

\begin{lstlisting}[language=C]
for(int i = 0; i < 5; i++){
    printf("%d\n", i);;;;;;;;;;;;;
}
\end{lstlisting}

It is OK to have this kind of code, because the C language uses
semicolons (;) to separate statements. If there is no statement in
between semicolons, then there is nothing to do and the compiler moves on to the next statement
To save a lot of confusion, just stick to always using braces.
It increases the number of lines of code, which is a great productivity metric.

\section{Topics}

\begin{itemize}
	\tightlist
	\item
	      C Strings representation
	\item
	      C Strings as pointers
	\item
	      char p{[}{]}vs char* p
	\item
	      Simple C string functions (strcmp, strcat, strcpy)
	\item
	      sizeof char
	\item
	      sizeof x vs x*
	\item
	      Heap memory lifetime
	\item
	      Calls to heap allocation
	\item
	      Dereferencing pointers
	\item
	      Address-of operator
	\item
	      Pointer arithmetic
	\item
	      String duplication
	\item
	      String truncation
	\item
	      double-free error
	\item
	      String literals
	\item
	      Print formatting.
	\item
	      memory out of bounds errors
	\item
	      static memory
	\item
	      fileio POSIX vs.~C library
	\item
	      C io fprintf and printf
	\item
	      POSIX file IO (read, write, open)
	\item
	      Buffering of stdout
\end{itemize}

\section{Questions/Exercises}

\begin{itemize}
	\item
	      What does the following print out?

	      \begin{lstlisting}[language=C]
int main(){
fprintf(stderr, "Hello ");
fprintf(stdout, "It's a small ");
fprintf(stderr, "World\n");
fprintf(stdout, "place\n");
return 0;
}
\end{lstlisting}
	\item
	      What are the differences between the following two declarations? What
	      does \keyword{sizeof} return for one of them?

	      \begin{lstlisting}[language=C]
char str1[] = "bhuvan";
char *str2 = "another one";
\end{lstlisting}
	\item
	      What is a string in c?
	\item
	      Code up a simple \keyword{my\_strcmp}. How about \keyword{my\_strcat}, \keyword{my\_strcpy}, or \keyword{my\_strdup}? Bonus: Code the functions while only going through the strings \emph{once}.
	\item
	      What should the following usually return?

	      \begin{lstlisting}[language=C]
int *ptr;
sizeof(ptr);
sizeof(*ptr);
\end{lstlisting}
	\item
	      What is \keyword{malloc}? How is it different than \keyword{calloc}. Once memory is \keyword{malloc}ed how can I use \keyword{realloc}?
	\item
	      What is the \keyword{\&} operator? How about \keyword{*}?
	\item
	      Pointer Arithmetic. Assume the following addresses. What are the following shifts?

	      \begin{lstlisting}[language=C]
char** ptr = malloc(10); //0x100
ptr[0] = malloc(20); //0x200
ptr[1] = malloc(20); //0x300
\end{lstlisting}

	      \begin{itemize}
		      \tightlist
		      \item
		            \keyword{ptr\ +\ 2}
		      \item
		            \keyword{ptr\ +\ 4}
		      \item
		            \keyword{ptr{[}0{]}\ +\ 4}
		      \item
		            \keyword{ptr{[}1{]}\ +\ 2000}
		      \item
		            \keyword{*((int)(ptr\ +\ 1))\ +\ 3}
	      \end{itemize}
	\item
	      How do we prevent double free errors?
	\item
	      What is the printf specifier to print a string, \keyword{int}, or
	      \keyword{char}?
	\item
	      Is the following code valid? If so, why? Where is \keyword{output}
	      located?

	      \begin{lstlisting}[language=C]
char *foo(int var){
static char output[20];
snprintf(output, 20, "%d", var);
return output;
}
\end{lstlisting}
	\item
	      Write a function that accepts a string and opens that file prints out the file 40 bytes at a time but every other print reverses the string (try using POSIX API for this).
	\item
	      What are some differences between the POSIX file descriptor model and C's \keyword{FILE*} (ie what function calls are used and which is buffered)? Does POSIX use C's \keyword{FILE*} internally or vice versa?
\end{itemize}

\section{Rapid Fire: Pointer Arithmetic}

Pointer arithmetic is really important! You need to know how many bytes each pointer is moved by with each addition. The following is a rapid fire section. We'll use the following definitions

\begin{lstlisting}[language=C]
int *int_; // sizeof(int) == 4;
long *long_; // sizeof(long) == 8;
char *char_;
int *short_; //sizeof(short) == 2;
int **int_ptr; // sizeof(int*) == 8;
\end{lstlisting}

How many bytes are moved over from the following additions?

\begin{enumerate}
\item \keyword{int\_ + 1}
\item \keyword{long\_ + 7}
\item \keyword{short\_ - 6}
\item \keyword{short\_ - sizeof(long)}
\item \keyword{long\_ - sizeof(long) + sizeof(int\_)}
\item \keyword{long\_ - sizeof(long) / sizeof(int)}
\item \keyword{(char*)(int\_ptr + sizeof(long)) + sizeof(int\_)}
\end{enumerate}

\subsection{Rapid Fire Solutions}

\begin{enumerate}
\item 4
\item 56
\item -12
\item -16
\item 0
\item -16
\item 72
\end{enumerate}

\bibliographystyle{plainnat}
\bibliography{introc/introc}
