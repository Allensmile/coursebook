\section{Preprocessor}

What is the preprocessor? Preprocessing is a copy and paste operation that the compiler performs \textbf{before} actually compiling the program.

Here is an example of a substitution:

\begin{lstlisting}[language=C]
// Before preprocessing
#define MAX_LENGTH 10
char buffer[MAX_LENGTH]
// After preprocessing
char buffer[10]
\end{lstlisting}

There are side effects to the preprocessor though.
One problem is that the preprocessor needs to be able to tokenize properly, meaning trying to redefine the internals of the C language with a preprocessor may be impossible.
Another problem is that they can't be nested infinitely -- there is a bounded depth where they need to stop.
Macros are also just simple text substitutions, without semantics.
For example, look at what can happen if we have a macro that performs an inline modification.

\begin{lstlisting}[language=C]
#define min(a,b) ((a)<(b) ? (a) : (b))
int main() {
  int x = 4;
  if(min(x++, 5)) printf("%d is six", x);
  return 0;
}
\end{lstlisting}

Macros are simple text substitution so the above example expands to \keyword{x++\ \textless{}\ 100\ ?\ x++\ :\ 100} (parenthesis omitted for clarity).
Now for this case, it is opaque what gets printed out, but it will be 6.
Also consider the edge case when operator precedence comes into play. This is what is meant by lack of semantics.

\begin{lstlisting}[language=C]
#define min(a,b) a < b ? a : b
int x = 99;
int r = 10 + min(99, 100); // r is 100!
// This is what it is expanded to
int r = 10 + 99 < 100 ? 99 : 100
// Which means
int r = (10 + 99) < 100 ? 99 : 100
\end{lstlisting}

You can also have logical problems with the flexibility of certain parameters.
One common source of confusion is with static arrays and the \keyword{sizeof} operator.

\begin{lstlisting}[language=C]
#define ARRAY_LENGTH(A) (sizeof((A)) / sizeof((A)[0]))
int static_array[10]; // ARRAY_LENGTH(static_array) = 10
int* dynamic_array = malloc(10); // ARRAY_LENGTH(dynamic_array) = 2 or 1
\end{lstlisting}

What is wrong with the macro? Well, it works if we have a static array like the first array because \keyword{sizeof} a static array returns the number of bytes that array takes up, and dividing it by the \keyword{sizeof(an\_element)} would give you the number of entries.
But if we use a pointer to a piece of memory, taking the sizeof the pointer and dividing it by the size of the first entry won't always give us the size of the array.

\subsection{Extra: Includes and conditionals}

The other preprocessor include is the \keyword{\#include} directive and conditionals.
The include directive is explained by example.

\begin{lstlisting}[language=C]
// foo.h
int bar();
\end{lstlisting}

\begin{lstlisting}[language=C]
// foo.c unpreprocessed
#include "foo.h"
int bar() {
}
\end{lstlisting}

After preprocessing, the compiler sees this

\begin{lstlisting}[language=C]
// foo.c unpreprocessed
int bar();

int bar() {

}
\end{lstlisting}

The other thing we have is conditionals.
If a macro is defined or equal to zeros, that branch is not taken.

\begin{lstlisting}[language=C]
int main() {
#ifdef __GNUC__
    return 1;
#else
    return 0;
#endif
}
\end{lstlisting}

Using \keyword{gcc} your compiler would see this:

\begin{lstlisting}[language=C]
int main() {
    return 1;
}
\end{lstlisting}


Using \keyword{clang} your compiler would see this:

\begin{lstlisting}[language=C]
int main() {
    return 0;
}
\end{lstlisting}


