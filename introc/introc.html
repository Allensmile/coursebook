<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<h1 id="want-a-quick-introduction-to-c">Want a quick introduction to C?</h1>
<ul>
<li><p>Keep reading for the quick crash-course to C Programming below</p></li>
<li><p>Then see the <span>[</span><span>[</span>C Gotchas wiki pageC Programming, Part 3: Common Gotchas<span>]</span><span>]</span>.</p></li>
<li><p>And learn about <span>[</span><span>[</span>text I/OC Programming, Part 2: Text Input And Output<span>]</span><span>]</span>.</p></li>
<li><p>Kick back relax with <a href="http://cs-education.github.io/sys/#">Lawrence’s intro videos</a> (Also there is a virtual machine-in-a-browser you can play with!)</p></li>
</ul>
<h1 id="external-resources">External resources</h1>
<ul>
<li><p><a href="https://learnxinyminutes.com/docs/c/">Learn X in Y</a> (Highly recommended to skim through!)</p></li>
<li><p><a href="http://www.ccs.neu.edu/course/com3620/parent/C-for-Java-C++/c-for-c++-alt.html">C for C++/Java Programmers</a></p></li>
<li><p><a href="http://www.lysator.liu.se/c/bwk-tutor.html">C Tutorial by Brian Kernighan</a></p></li>
<li><p><a href="http://c-faq.com/">c faq</a></p></li>
<li><p><a href="http://gribblelab.org/CBootCamp/index.html">C Bootcamp</a></p></li>
<li><p><a href="http://www.cplusplus.com/reference/clibrary/">C/C++ function reference</a></p></li>
<li><p><a href="http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html">gdb (Gnu debugger) tutorial</a> Tip: run gdb with the “-tui” command line argument to get a full-screen version of the debugger.</p></li>
<li><p>Add your favorite resources here</p></li>
</ul>
<h1 id="crash-course-intro-to-c">Crash course intro to C</h1>
<p><em>Warning new page</em> Please fix typos and formatting mistakes for me and add useful links too.*</p>
<h2 id="how-do-you-write-a-complete-hello-world-program-in-c">How do you write a complete hello world program in C?</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> main(<span class="dt">void</span>) { 
    printf(<span class="st">&quot;Hello World</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">return</span> <span class="dv">0</span>; 
}</code></pre></div>
<h2 id="why-do-we-use-include-stdio.h">Why do we use #include &lt;stdio.h&gt;?</h2>
<p>We’re lazy! We don’t want to declare the <code>printf</code> function. It’s already done for us inside the file ‘<code>stdio.h</code>’. The <code>#include</code> includes the text of the file as part of our file to be compiled.</p>
<p>Specifically, the <code>#include</code> directive takes the file <code>stdio.h</code> (which stands for <strong>st</strong>an<strong>d</strong>ard <strong>i</strong>nput and <strong>o</strong>utput) located somewhere in your operating system, copies the text, and substitutes it where the <code>#include</code> was.</p>
<h2 id="how-are-c-strings-represented">How are C strings represented?</h2>
<p>They are represented as characters in memory. The end of the string includes a NULL (0) byte. So “ABC” requires four(4) bytes <code>[A,B,C,\0</code>. The only way to find out the length of a C string is to keep reading memory until you find the NULL byte. C characters are always exactly one byte each.</p>
<p>When you write a string literal <code>ABC</code> in an expression the string literal evaluates to a char pointer (<code>char </code>), which points to the first byte/char of the string. This means <code>ptr</code> in the example below will hold the memory address of the first character in the string.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *ptr = <span class="st">&quot;ABC&quot;</span></code></pre></div>
<p>Some common ways to initialize a string include:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *str = <span class="st">&quot;ABC&quot;</span>;
<span class="dt">char</span> str[] = <span class="st">&quot;ABC&quot;</span>;
<span class="dt">char</span> str[]={&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;\<span class="dv">0</span>&#39;};</code></pre></div>
<h2 id="how-do-you-declare-a-pointer">How do you declare a pointer?</h2>
<p>A pointer refers to a memory address. The type of the pointer is useful - it tells the compiler how many bytes need to be read/written. You can declare a pointer as follows.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *ptr1;
<span class="dt">char</span> *ptr2;</code></pre></div>
<p>Due to C’s grammar, an <code>int*</code> or any pointer is not actually its own type. You have to precede each pointer variable with an asterisk. As a common gotcha, the following</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span>* ptr3, ptr4;</code></pre></div>
<p>Will only declare <code>*ptr3</code> as a pointer. <code>ptr4</code> will actually be a regular int variable. To fix this declaration, keep the <code>*</code> preceding to the pointer</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *ptr3, *ptr4;</code></pre></div>
<h2 id="how-do-you-use-a-pointer-to-readwrite-some-memory">How do you use a pointer to read/write some memory?</h2>
<p>Let’s say that we declare a pointer <code>int ptr</code>. For the sake of discussion, let’s say that <code>ptr</code> points to memory address <code>0x1000</code>. If we want to write to a pointer, we can dereference and assign <code>*ptr</code>.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">*ptr = <span class="dv">0</span>; <span class="co">// Writes some memory.</span></code></pre></div>
<p>What C will do is take the type of the pointer which is an <code>int</code> and writes <code>sizeof(int)</code> bytes from the start of the pointer, meaning that bytes <code>0x1000</code>, <code>0x1001</code>, <code>0x1002</code>, <code>0x1003</code> will all be zero. The number of bytes written depends on the pointer type. It is the same for all primitive types but structs are a little different.</p>
<h2 id="what-is-pointer-arithmetic">What is pointer arithmetic?</h2>
<p>You can add an integer to a pointer. However, the pointer type is used to determine how much to increment the pointer. For char pointers this is trivial because characters are always one byte:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *ptr = <span class="st">&quot;Hello&quot;</span>; <span class="co">// ptr holds the memory location of &#39;H&#39;</span>
ptr += <span class="dv">2</span>; <span class="co">//ptr now points to the first&#39;l&#39;</span></code></pre></div>
<p>If an int is 4 bytes then ptr+1 points to 4 bytes after whatever ptr is pointing at.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *ptr = <span class="st">&quot;ABCDEFGH&quot;</span>;
<span class="dt">int</span> *bna = (<span class="dt">int</span> *) ptr;
bna +=<span class="dv">1</span>; <span class="co">// Would cause iterate by one integer space (i.e 4 bytes on some systems)</span>
ptr = (<span class="dt">char</span> *) bna;
printf(<span class="st">&quot;%s&quot;</span>, ptr);
<span class="co">/* Notice how only &#39;EFGH&#39; is printed. Why is that? Well as mentioned above, when performing &#39;bna+=1&#39; we are increasing the **integer** pointer by 1, (translates to 4 bytes on most systems) which is equivalent to 4 characters (each character is only 1 byte)*/</span>
<span class="kw">return</span> <span class="dv">0</span>;</code></pre></div>
<p>Because pointer arithmetic in C is always automatically scaled by the size of the type that is pointed to, you can’t perform pointer arithmetic on void pointers.</p>
<p>You can think of pointer arithmetic in C as essentially doing the following</p>
<p>If I want to do</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *ptr1 = ...;
<span class="dt">int</span> *offset = ptr1 + <span class="dv">4</span>;</code></pre></div>
<p>Think</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *ptr1 = ...;
<span class="dt">char</span> *temp_ptr1 = (<span class="dt">char</span>*) ptr1;
<span class="dt">int</span> *offset = (<span class="dt">int</span>*)(temp_ptr1 + <span class="kw">sizeof</span>(<span class="dt">int</span>)*<span class="dv">4</span>);</code></pre></div>
<p>To get the value. <strong>Every time you do pointer arithmetic, take a deep breath and make sure that you are shifting over the number of bytes you think you are shifting over.</strong></p>
<h2 id="what-is-a-void-pointer">What is a void pointer?</h2>
<p>A pointer without a type (very similar to a void variable). Void pointers are used when either a datatype you’re dealing with is unknown or when you’re interfacing C code with other programming languages. You can think of this as a raw pointer, or just a memory address. You cannot directly read or write to it because the void type does not have a size. For Example</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> *give_me_space = malloc(<span class="dv">10</span>);
<span class="dt">char</span> *string = give_me_space;</code></pre></div>
<p>This does not require a cast because C automatically promotes <code>void*</code> to its appropriate type. <strong>Note:</strong></p>
<p>gcc and clang are not total ISO-C compliant, meaning that they will let you do arithmetic on a void pointer. They will treat it as a char pointer but do not do this because it may not work with all compilers!</p>
<h2 id="does-printf-call-write-or-does-write-call-printf">Does printf call write or does write call printf?</h2>
<p><code>printf</code> calls <code>write</code>. <code>printf</code> includes an internal buffer so, to increase performance <code>printf</code> may not call <code>write</code> everytime you call <code>printf</code>. <code>printf</code> is a C library function. <code>write</code> is a system call and as we know system calls are expensive. On the other hand, <code>printf</code> uses a buffer which suits our needs better at that point</p>
<h2 id="how-do-you-print-out-pointer-values-integers-strings">How do you print out pointer values? integers? strings?</h2>
<p>Use format specifiers “%p” for pointers, “%d” for integers and “%s” for Strings. A full list of all of the format specifiers is found <a href="http://www.cplusplus.com/reference/cstdio/printf/">here</a></p>
<p>Example of integer:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> num1 = <span class="dv">10</span>;
printf(<span class="st">&quot;%d&quot;</span>, num1); <span class="co">//prints num1</span></code></pre></div>
<p>Example of integer pointer:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *ptr = (<span class="dt">int</span> *) malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));
*ptr = <span class="dv">10</span>;
printf(<span class="st">&quot;%p</span><span class="ch">\n</span><span class="st">&quot;</span>, ptr); <span class="co">//prints the address pointed to by the pointer</span>
printf(<span class="st">&quot;%p</span><span class="ch">\n</span><span class="st">&quot;</span>, &amp;ptr); <span class="co">/*prints the address of pointer -- extremely useful</span>
<span class="co">when dealing with double pointers*/</span>
printf(<span class="st">&quot;%d&quot;</span>, *ptr); <span class="co">//prints the integer content of ptr</span>
<span class="kw">return</span> <span class="dv">0</span>;</code></pre></div>
<p>Example of string:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *str = (<span class="dt">char</span> *) malloc(<span class="dv">256</span> * <span class="kw">sizeof</span>(<span class="dt">char</span>));
strcpy(str, <span class="st">&quot;Hello there!&quot;</span>);
printf(<span class="st">&quot;%p</span><span class="ch">\n</span><span class="st">&quot;</span>, str); <span class="co">// print the address in the heap</span>
printf(<span class="st">&quot;%s&quot;</span>, str);
<span class="kw">return</span> <span class="dv">0</span>;</code></pre></div>
<p><a href="https://www.cs.bu.edu/teaching/c/string/intro/">Strings as Pointers &amp; Arrays @ BU</a></p>
<h2 id="how-would-you-make-standard-out-be-saved-to-a-file">How would you make standard out be saved to a file?</h2>
<p>Simplest way: run your program and use shell redirection e.g.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">./program &gt; output.txt

<span class="er">#To read the contents of the file,</span>
cat output.txt</code></pre></div>
<p>More complicated way: close(1) and then use open to re-open the file descriptor. See <span>[</span><span>[</span>http://cs-education.github.io/sys/#chapter/0/section/3/activity/0<span>]</span><span>]</span> ## What’s the difference between a pointer and an array? Give an example of something you can do with one but not the other.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> ary[] = <span class="st">&quot;Hello&quot;</span>;
<span class="dt">char</span> *ptr = <span class="st">&quot;Hello&quot;</span>;</code></pre></div>
<p>Example</p>
<p>The array name points to the first byte of the array. Both <code>ary</code> and <code>ptr</code> can be printed out:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> ary[] = <span class="st">&quot;Hello&quot;</span>;
<span class="dt">char</span> *ptr = <span class="st">&quot;Hello&quot;</span>;
<span class="co">// Print out address and contents</span>
printf(<span class="st">&quot;%p : %s</span><span class="ch">\n</span><span class="st">&quot;</span>, ary, ary);
printf(<span class="st">&quot;%p : %s</span><span class="ch">\n</span><span class="st">&quot;</span>, ptr, ptr);</code></pre></div>
<p>The array is mutable, so we can change its contents (be careful not to write bytes beyond the end of the array though). Fortunately, ‘World’ is no longer than ’Hello&quot;</p>
<p>In this case, the char pointer <code>ptr</code> points to some read-only memory (where the statically allocated string literal is stored), so we cannot change those contents.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">strcpy(ary, <span class="st">&quot;World&quot;</span>); <span class="co">// OK</span>
strcpy(ptr, <span class="st">&quot;World&quot;</span>); <span class="co">// NOT OK - Segmentation fault (crashes)</span></code></pre></div>
<p>We can, however, unlike the array, we change <code>ptr</code> to point to another piece of memory,</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">ptr = <span class="st">&quot;World&quot;</span>; <span class="co">// OK!</span>
ptr = ary; <span class="co">// OK!</span>
ary = (..anything..) ; <span class="co">// WONT COMPILE</span>
<span class="co">// ary is doomed to always refer to the original array.</span>
printf(<span class="st">&quot;%p : %s</span><span class="ch">\n</span><span class="st">&quot;</span>, ptr, ptr);
strcpy(ptr, <span class="st">&quot;World&quot;</span>); <span class="co">// OK because now ptr is pointing to mutable memory (the array)</span></code></pre></div>
<p>What to take away from this is that pointers * can point to any type of memory while C arrays <span>[</span><span>]</span> can only point to memory on the stack. In a more common case, pointers will point to heap memory in which case the memory referred to by the pointer CAN be modified.</p>
<h2 id="sizeof-returns-the-number-of-bytes.-so-using-above-code-what-is-sizeofary-and-sizeofptr">sizeof() returns the number of bytes. So using above code, what is sizeof(ary) and sizeof(ptr)?</h2>
<p><code>sizeof(ary)</code>: <code>ary</code> is an array. Returns the number of bytes required for the entire array (5 chars + zero byte = 6 bytes) <code>sizeof(ptr)</code>: Same as sizeof(char *). Returns the number bytes required for a pointer (e.g. 4 or 8 for a 32 bit or 64-bit machine) <code>sizeof</code> is a special operator. Really it’s something the compiler substitutes in before compiling the program because the size of all types is known at compile time. When you have <code>sizeof(char*)</code> that takes the size of a pointer on your machine (8 bytes for a 64-bit machine and 4 for a 32 bit and so on). When you try <code>sizeof(char[])</code>, the compiler looks at that and substitutes the number of bytes that the <strong>entire</strong> array contains because the total size of the array is known at compile time.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> str1[] = <span class="st">&quot;will be 11&quot;</span>;
<span class="dt">char</span>* str2 = <span class="st">&quot;will be 8&quot;</span>;
<span class="kw">sizeof</span>(str1) <span class="co">//11 because it is an array</span>
<span class="kw">sizeof</span>(str2) <span class="co">//8 because it is a pointer</span></code></pre></div>
<p>Be careful, using sizeof for the length of a string!</p>
<h2 id="which-of-the-following-code-is-incorrect-or-correct-and-why">Which of the following code is incorrect or correct and why?</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span>* f1(<span class="dt">int</span> *p) {
    *p = <span class="dv">42</span>;
    <span class="kw">return</span> p;
} <span class="co">// This code is correct;</span></code></pre></div>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* f2() {
    <span class="dt">char</span> p[] = <span class="st">&quot;Hello&quot;</span>;
    <span class="kw">return</span> p;
} <span class="co">// Incorrect!</span></code></pre></div>
<p>Explanation: An array p is created on the stack for the correct size to hold H,e,l,l,o, and a null byte i.e. (6) bytes. This array is stored on the stack and is invalid after we return from f2.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* f3() {
    <span class="dt">char</span> *p = <span class="st">&quot;Hello&quot;</span>;
    <span class="kw">return</span> p;
} <span class="co">// OK</span></code></pre></div>
<p>Explanation: p is a pointer. It holds the address of the string constant. The string constant is unchanged and valid even after f3 returns.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* f4() {
    <span class="dt">static</span> <span class="dt">char</span> p[] = <span class="st">&quot;Hello&quot;</span>;
    <span class="kw">return</span> p;
} <span class="co">// OK</span></code></pre></div>
<p>Explanation: The array is static meaning it exists for the lifetime of the process (static variables are not on the heap or the stack).</p>
<h2 id="how-do-you-look-up-information-c-library-calls-and-system-calls">How do you look up information C library calls and system calls?</h2>
<p>Use the man pages. Note the man pages are organized into sections. Section 2 = System calls. Section 3 = C libraries. Web: Google “man7 open” shell: man -S2 open or man -S3 printf</p>
<h2 id="how-do-you-allocate-memory-on-the-heap">How do you allocate memory on the heap?</h2>
<p>Use malloc. There’s also realloc and calloc. Typically used with sizeof. e.g. enough space to hold 10 integers</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *space = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>) * <span class="dv">10</span>);</code></pre></div>
<h2 id="whats-wrong-with-this-string-copy-code">What’s wrong with this string copy code?</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> mystrcpy(<span class="dt">char</span>*dest, <span class="dt">char</span>* src) { 
  <span class="co">// void means no return value   </span>
  <span class="kw">while</span>( *src ) { dest = src; src ++; dest++; }  
}</code></pre></div>
<p>In the above code it simply changes the dest pointer to point to source string. Also the nuls bytes are not copied. Here’s a better version -</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">  <span class="kw">while</span>( *src ) { *dest = *src; src ++; dest++; } 
  *dest = *src;</code></pre></div>
<p>Note it’s also usual to see the following kind of implementation, which does everything inside the expression test, including copying the nul byte.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">  <span class="kw">while</span>( (*dest++ = *src++ )) {};</code></pre></div>
<h2 id="how-do-you-write-a-strdup-replacement">How do you write a strdup replacement?</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// Use strlen+1 to find the zero byte... </span>
<span class="dt">char</span>* mystrdup(<span class="dt">char</span>*source) {
   <span class="dt">char</span> *p = (<span class="dt">char</span> *) malloc ( strlen(source)+<span class="dv">1</span> );
   strcpy(p,source);
   <span class="kw">return</span> p;
}</code></pre></div>
<h2 id="how-do-you-unallocate-memory-on-the-heap">How do you unallocate memory on the heap?</h2>
<p>Use free!</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *n = (<span class="dt">int</span> *) malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));
*n = <span class="dv">10</span>;
<span class="co">//Do some work</span>
free(n);</code></pre></div>
<h2 id="what-is-double-free-error-how-can-you-avoid-what-is-a-dangling-pointer-how-do-you-avoid">What is double free error? How can you avoid? What is a dangling pointer? How do you avoid?</h2>
<p>A double free error is when you accidentally attempt to free the same allocation twice.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *p = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));
free(p);

*p = <span class="dv">123</span>; <span class="co">// Oops! - Dangling pointer! Writing to memory we don&#39;t own anymore</span>

free(p); <span class="co">// Oops! - Double free!</span></code></pre></div>
<p>The fix is first to write correct programs! Secondly, it’s good programming hygiene to reset pointers once the memory has been freed. This ensures the pointer can’t be used incorrectly without the program crashing.</p>
<p>Fix:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">p = NULL; <span class="co">// Now you can&#39;t use this pointer by mistake</span></code></pre></div>
<h2 id="what-is-an-example-of-buffer-overflow">What is an example of buffer overflow?</h2>
<p>Famous example: Heart Bleed (performed a memcpy into a buffer that was of insufficient size). Simple example: implement a strcpy and forget to add one to strlen, when determining the size of the memory required.</p>
<h2 id="what-is-typedef-and-how-do-you-use-it">What is typedef and how do you use it?</h2>
<p>Declares an alias for a type. Often used with structs to reduce the visual clutter of having to write ‘struct’ as part of the type.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">float</span> real; 
real gravity = <span class="dv">10</span>;
<span class="co">// Also typedef gives us an abstraction over the underlying type used. </span>
<span class="co">// In the future, we only need to change this typedef if we</span>
<span class="co">// wanted our physics library to use doubles instead of floats.</span>

<span class="kw">typedef</span> <span class="kw">struct</span> link link_t; 
<span class="co">//With structs, include the keyword &#39;struct&#39; as part of the original types</span></code></pre></div>
<p>In this class, we regularly typedef functions. A typedef for a function can be this for example</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">int</span> (*comparator)(<span class="dt">void</span>*,<span class="dt">void</span>*);

<span class="dt">int</span> greater_than(<span class="dt">void</span>* a, <span class="dt">void</span>* b){
    <span class="kw">return</span> a &gt; b;
}
comparator gt = greater_than;</code></pre></div>
<p>This declares a function type comparator that accepts two <code>void*</code> params and returns an integer.</p>
<h1 id="printing-to-streams">Printing to Streams</h1>
<h2 id="how-do-i-print-strings-ints-chars-to-the-standard-output-stream">How do I print strings, ints, chars to the standard output stream?</h2>
<p>Use <code>printf</code>. The first parameter is a format string that includes placeholders for the data to be printed. Common format specifiers are <code>%s</code> treat the argument as a c string pointer, keep printing all characters until the NULL-character is reached; <code>%d</code> print the argument as an integer; <code>%p</code> print the argument as a memory address.</p>
<p>A simple example is shown below:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *name = ... ; <span class="dt">int</span> score = ...;
printf(<span class="st">&quot;Hello %s, your result is %d</span><span class="ch">\n</span><span class="st">&quot;</span>, name, score);
printf(<span class="st">&quot;Debug: The string and int are stored at: %p and %p</span><span class="ch">\n</span><span class="st">&quot;</span>, name, &amp;score );
<span class="co">// name already is a char pointer and points to the start of the array. </span>
<span class="co">// We need &quot;&amp;&quot; to get the address of the int variable</span></code></pre></div>
<p>By default, for performance, <code>printf</code> does not actually write anything out (by calling write) until its buffer is full or a newline is printed.</p>
<h2 id="how-else-can-i-print-strings-and-single-characters">How else can I print strings and single characters?</h2>
<p>Use <code>puts( name )</code> and <code>putchar( c )</code> where name is a pointer to a C string and c is just a <code>char</code></p>
<h2 id="how-do-i-print-to-other-file-streams">How do I print to other file streams?</h2>
<p>Use <code>fprintf( _file_ , Hello %s, score: %d, name, score);</code> Where _file_ is either predefined ‘stdout’ ‘stderr’ or a FILE pointer that was returned by <code>fopen</code> or <code>fdopen</code></p>
<h2 id="can-i-use-file-descriptors">Can I use file descriptors?</h2>
<p>Yes! Just use <code>dprintf(int fd, char* format_string, ...);</code> Just remember the stream may be buffered, so you will need to assure that the data is written to the file descriptor.</p>
<h2 id="how-do-i-print-data-into-a-c-string">How do I print data into a C string?</h2>
<p>Use <code>sprintf</code> or better <code>snprintf</code>.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> result[<span class="dv">200</span>];
<span class="dt">int</span> len = snprintf(result, <span class="kw">sizeof</span>(result), <span class="st">&quot;%s:%d&quot;</span>, name, score);</code></pre></div>
<p>snprintf returns the number of characters written excluding the terminating byte. In the above example, this would be a maximum of 199.</p>
<h2 id="what-if-i-really-really-want-printf-to-call-write-without-a-newline">What if I really really want printf to call write without a newline?</h2>
<p>Use <code>fflush( FILE* inp )</code>. The contents of the file will be written. If I wanted to write “Hello World” with no newline, I could write it like this.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main(){
    fprintf(stdout, <span class="st">&quot;Hello World&quot;</span>);
    fflush(stdout);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="how-is-perror-helpful">How is perror helpful?</h2>
<p>Let’s say that you have a function call that just failed (because you checked the man page and it is a failing return code). <code>perror(const char* message)</code> will print the English version of the error to stderr</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main(){
    <span class="dt">int</span> ret = open(<span class="st">&quot;IDoNotExist.txt&quot;</span>, O_RDONLY);
    <span class="kw">if</span>(ret &lt; <span class="dv">0</span>){
        perror(<span class="st">&quot;Opening IDoNotExist:&quot;</span>);
    }
    <span class="co">//...</span>
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h1 id="parsing-input">Parsing Input</h1>
<h2 id="how-do-i-parse-numbers-from-strings">How do I parse numbers from strings?</h2>
<p>Use <code>long int strtol(const char nptr, char *endptr, int base);</code> or <code>long long int strtoll(const char nptr, char *endptr, int base);</code>.</p>
<p>What these functions do is take the pointer to your string <code>*nptr</code> and a <code>base</code> (ie binary, octal, decimal, hexadecimal etc) and an optional pointer <code>endptr</code> and returns a parsed value.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main(){
    <span class="dt">const</span> <span class="dt">char</span> *nptr = <span class="st">&quot;1A2436&quot;</span>;
    <span class="dt">char</span>* endptr;
    <span class="dt">long</span> <span class="dt">int</span> result = strtol(nptr, &amp;endptr, <span class="dv">16</span>);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>Be careful though! Error handling is tricky because the function won’t return an error code. If you give it a string that is not a number it will return 0. This means you cant differentiate between a valid “0” and an invalid string. See the man page for more details on strol behavior with invalid and out of bounds values. A safer alternative is use to <code>sscanf</code> (and check the return value).</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main(){
    <span class="dt">const</span> <span class="dt">char</span> *input = <span class="st">&quot;0&quot;</span>; <span class="co">// or &quot;!##@&quot; or &quot;&quot;</span>
    <span class="dt">char</span>* endptr;
    <span class="dt">long</span> <span class="dt">int</span> parsed = strtol(input, &amp;endptr, <span class="dv">10</span>);
    <span class="kw">if</span>(parsed == <span class="dv">0</span>){
        <span class="co">// Either the input string was not a valid base-10 number or it really was zero!</span>

    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<h2 id="how-do-i-parse-input-using-scanf-into-parameters">How do I parse input using scanf into parameters?</h2>
<p>Use <code>scanf</code> (or <code>fscanf</code> or <code>sscanf</code>) to get input from the default input stream, an arbitrary file stream or a C string respectively. It’s a good idea to check the return value to see how many items were parsed. <code>scanf</code> functions require valid pointers. It’s a common source of error to pass in an incorrect pointer value. For example,</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *data = (<span class="dt">int</span> *) malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));
<span class="dt">char</span> *line = <span class="st">&quot;v 10&quot;</span>;
<span class="dt">char</span> type;
<span class="co">// Good practice: Check scanf parsed the line and read two values:</span>
<span class="dt">int</span> ok = <span class="dv">2</span> == sscanf(line, <span class="st">&quot;%c %d&quot;</span>, &amp;type, &amp;data); <span class="co">// pointer error</span></code></pre></div>
<p>We wanted to write the character value into c and the integer value into the malloc’d memory. However, we passed the address of the data pointer, not what the pointer is pointing to! So <code>sscanf</code> will change the pointer itself. i.e. the pointer will now point to address 10 so this code will later fail e.g. when free(data) is called.</p>
<h2 id="how-do-i-stop-scanf-from-causing-a-buffer-overflow">How do I stop scanf from causing a buffer overflow?</h2>
<p>The following code assumes the scanf won’t read more than 10 characters (including the terminating byte) into the buffer.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> buffer[<span class="dv">10</span>];
scanf(<span class="st">&quot;%s&quot;</span>,buffer);</code></pre></div>
<p>You can include an optional integer to specify how many characters EXCLUDING the terminating byte:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> buffer[<span class="dv">10</span>];
scanf(<span class="st">&quot;%9s&quot;</span>, buffer); <span class="co">// reads up to 9 charactes from input (leave room for the 10th byte to be the terminating byte)</span></code></pre></div>
<h2 id="why-is-gets-dangerous-what-should-i-use-instead">Why is gets dangerous? What should I use instead?</h2>
<p>The following code is vulnerable to buffer overflow. It assumes or trusts that the input line will be no more than 10 characters, including the terminating byte.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> buf[<span class="dv">10</span>];
gets(buf); <span class="co">// Remember the array name means the first byte of the array</span></code></pre></div>
<p><code>gets</code> is deprecated in C99 standard and has been removed from the latest C standard (C11). Programs should use <code>fgets</code> or <code>getline</code> instead.</p>
<p>Where each has the following structure respectively:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *fgets (<span class="dt">char</span> *str, <span class="dt">int</span> num, FILE *stream); 

ssize_t getline(<span class="dt">char</span> **lineptr, size_t *n, FILE *stream);</code></pre></div>
<p>Here’s a simple, safe way to read a single line. Lines longer than 9 characters will be truncated:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> buffer[<span class="dv">10</span>];
<span class="dt">char</span> *result = fgets(buffer, <span class="kw">sizeof</span>(buffer), stdin);</code></pre></div>
<p>The result is NULL if there was an error or the end of the file is reached. Note, unlike <code>gets</code>, <code>fgets</code> copies the newline into the buffer, which you may want to discard-</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">if</span> (!result) { <span class="kw">return</span>; <span class="co">/* no data - don&#39;t read the buffer contents */</span>}

<span class="dt">int</span> i = strlen(buffer) - <span class="dv">1</span>;
<span class="kw">if</span> (buffer[i] == <span class="ch">&#39;\n&#39;</span>) 
    buffer[i] = &#39;\<span class="dv">0</span>&#39;;</code></pre></div>
<h2 id="how-do-i-use-getline">How do I use getline?</h2>
<p>One of the advantages of <code>getline</code> is that will automatically (re-) allocate a buffer on the heap of sufficient size.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// ssize_t getline(char **lineptr, size_t *n, FILE *stream);</span>

 <span class="co">/* set buffer and size to 0; they will be changed by getline */</span>
<span class="dt">char</span> *buffer = NULL;
size_t size = <span class="dv">0</span>;

ssize_t chars = getline(&amp;buffer, &amp;size, stdin);

<span class="co">// Discard newline character if it is present,</span>
<span class="kw">if</span> (chars &gt; <span class="dv">0</span> &amp;&amp; buffer[chars<span class="dv">-1</span>] == <span class="ch">&#39;\n&#39;</span>) 
    buffer[chars<span class="dv">-1</span>] = &#39;\<span class="dv">0</span>&#39;;

<span class="co">// Read another line.</span>
<span class="co">// The existing buffer will be re-used, or, if necessary,</span>
<span class="co">// It will be `free`&#39;d and a new larger buffer will `malloc`&#39;d</span>
chars = getline(&amp;buffer, &amp;size, stdin);

<span class="co">// Later... don&#39;t forget to free the buffer!</span>
free(buffer);</code></pre></div>
<p>What common mistakes do C programmers make?</p>
<h1 id="memory-mistakes">Memory mistakes</h1>
<h2 id="string-constants-are-constant">String constants are constant</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> array[] = <span class="st">&quot;Hi!&quot;</span>; <span class="co">// array contains a mutable copy </span>
strcpy(array, <span class="st">&quot;OK&quot;</span>);

<span class="dt">char</span> *ptr = <span class="st">&quot;Can&#39;t change me&quot;</span>; <span class="co">// ptr points to some immutable memory</span>
strcpy(ptr, <span class="st">&quot;Will not work&quot;</span>);</code></pre></div>
<p>String literals are character arrays stored in the code segment of the program, which is immutable. Two string literals may share the same space in memory. An example follows:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *str1 = <span class="st">&quot;Brandon Chong is the best TA&quot;</span>;
<span class="dt">char</span> *str2 = <span class="st">&quot;Brandon Chong is the best TA&quot;</span>;</code></pre></div>
<p>The strings pointed to by <code>str1</code> and <code>str2</code> may actually reside in the same location in memory.</p>
<p>Char arrays, however, contain the literal value which has been copied from the code segment into either the stack or static memory. These following char arrays do not reside in the same place in memory.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> arr1[] = <span class="st">&quot;Brandon Chong didn&#39;t write this&quot;</span>;
<span class="dt">char</span> arr2[] = <span class="st">&quot;Brandon Chong didn&#39;t write this&quot;</span>;</code></pre></div>
<h2 id="buffer-overflow-underflow">Buffer overflow/ underflow</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define N (10)</span>
<span class="dt">int</span> i = N, array[N];
<span class="kw">for</span>( ; i &gt;= <span class="dv">0</span>; i--) array[i] = i;</code></pre></div>
<p>C does not check that pointers are valid. The above example writes into <code>array[10]</code> which is outside the array bounds. This can cause memory corruption because that memory location is probably being used for something else. In practice, this can be harder to spot because the overflow/underflow may occur in a library call e.g.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">gets(array); <span class="co">// Let&#39;s hope the input is shorter than my array!</span></code></pre></div>
<h2 id="returning-pointers-to-automatic-variables">Returning pointers to automatic variables</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *f() {
    <span class="dt">int</span> result = <span class="dv">42</span>;
    <span class="dt">static</span> <span class="dt">int</span> imok;
    <span class="kw">return</span> &amp;imok; <span class="co">// OK - static variables are not on the stack</span>
    <span class="kw">return</span> &amp;result; <span class="co">// Not OK</span>
}</code></pre></div>
<p>Automatic variables are bound to stack memory only for the lifetime of the function. After the function returns it is an error to continue to use the memory. ## Insufficient memory allocation</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> User {
   <span class="dt">char</span> name[<span class="dv">100</span>];
};
<span class="kw">typedef</span> <span class="kw">struct</span> User user_t;

user_t *user = (user_t *) malloc(<span class="kw">sizeof</span>(user));</code></pre></div>
<p>In the above example, we needed to allocate enough bytes for the struct. Instead, we allocated enough bytes to hold a pointer. Once we start using the user pointer we will corrupt memory. The correct code is shown below.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> User {
   <span class="dt">char</span> name[<span class="dv">100</span>];
};
<span class="kw">typedef</span> <span class="kw">struct</span> User user_t;

user_t * user = (user_t *) malloc(<span class="kw">sizeof</span>(user_t));</code></pre></div>
<h4 id="strings-require-strlens1-bytes">Strings require strlen(s)+1 bytes</h4>
<p>Every string must have a null byte after the last characters. To store the string “Hi” it takes 3 bytes: <span>[</span>H<span>]</span> <span>[</span>i<span>]</span> <span>[</span>.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">  <span class="dt">char</span> *strdup(<span class="dt">const</span> <span class="dt">char</span> *input) {  <span class="co">/* return a copy of &#39;input&#39; */</span>
    <span class="dt">char</span> *copy;
    copy = malloc(<span class="kw">sizeof</span>(<span class="dt">char</span>*));     <span class="co">/* nope! this allocates space for a pointer, not a string */</span>
    copy = malloc(strlen(input));     <span class="co">/* Almost...but what about the null terminator? */</span>
    copy = malloc(strlen(input) + <span class="dv">1</span>); <span class="co">/* That&#39;s right. */</span>
    strcpy(copy, input);   <span class="co">/* strcpy will provide the null terminator */</span>
    <span class="kw">return</span> copy;
}</code></pre></div>
<h2 id="using-uninitialized-variables">Using uninitialized variables</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> myfunction() {
  <span class="dt">int</span> x;
  <span class="dt">int</span> y = x + <span class="dv">2</span>;
...</code></pre></div>
<p>Automatic variables hold garbage (whatever bit pattern happened to be in memory). It is an error to assume that it will always be initialized to zero.</p>
<h2 id="assuming-uninitialized-memory-will-be-zeroed">Assuming Uninitialized memory will be zeroed</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> myfunct() {
   <span class="dt">char</span> array[<span class="dv">10</span>];
   <span class="dt">char</span> *p = malloc(<span class="dv">10</span>);</code></pre></div>
<p>Automatic (temporary variables) are not automatically initialized to zero. Heap allocations using malloc are not automatically initialized to zero.</p>
<h2 id="double-free">Double-free</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">  <span class="dt">char</span> *p = malloc(<span class="dv">10</span>);
  free(p);
<span class="co">//  .. later ...</span>
  free(p); </code></pre></div>
<p>It is an error to free the same block of memory twice. ## Dangling pointers</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">  <span class="dt">char</span> *p = malloc(<span class="dv">10</span>);
  strcpy(p, <span class="st">&quot;Hello&quot;</span>);
  free(p);
<span class="co">//  .. later ...</span>
  strcpy(p,<span class="st">&quot;World&quot;</span>); </code></pre></div>
<p>Pointers to freed memory should not be used. A defensive programming practice is to set pointers to null as soon as the memory is freed.</p>
<p>It is a good idea to turn free into the following snippet that automatically sets the freed variable to null right after:(vim - ultisnips)</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">snippet free <span class="st">&quot;free(something)&quot;</span> b
free(${<span class="dv">1</span>});
$<span class="dv">1</span> = NULL;
${<span class="dv">2</span>}
endsnippet</code></pre></div>
<h1 id="logic-and-program-flow-mistakes">Logic and Program flow mistakes</h1>
<h2 id="forgetting-break">Forgetting break</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> flag = <span class="dv">1</span>; <span class="co">// Will print all three lines.</span>
<span class="kw">switch</span>(flag) {
  <span class="kw">case</span> <span class="dv">1</span>: printf(<span class="st">&quot;I&#39;m printed</span><span class="ch">\n</span><span class="st">&quot;</span>);
  <span class="kw">case</span> <span class="dv">2</span>: printf(<span class="st">&quot;Me too</span><span class="ch">\n</span><span class="st">&quot;</span>);
  <span class="kw">case</span> <span class="dv">3</span>: printf(<span class="st">&quot;Me three</span><span class="ch">\n</span><span class="st">&quot;</span>);
}</code></pre></div>
<p>Case statements without a break will just continue onto the code of the next case statement. The correct code is shown below. The break for the last statements is unnecessary because there are no more cases to be executed after the last one. If more are added, it can cause some bugs.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> flag = <span class="dv">1</span>; <span class="co">// Will print only &quot;I&#39;m printed\n&quot;</span>
<span class="kw">switch</span>(flag) {
  <span class="kw">case</span> <span class="dv">1</span>: 
    printf(<span class="st">&quot;I&#39;m printed</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">break</span>;
  <span class="kw">case</span> <span class="dv">2</span>: 
    printf(<span class="st">&quot;Me too</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">break</span>;
  <span class="kw">case</span> <span class="dv">3</span>: 
    printf(<span class="st">&quot;Me three</span><span class="ch">\n</span><span class="st">&quot;</span>);
    <span class="kw">break</span>; <span class="co">//unnecessary</span>
}</code></pre></div>
<h2 id="equal-vs.equality">Equal vs. equality</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> answer = <span class="dv">3</span>; <span class="co">// Will print out the answer.</span>
<span class="kw">if</span> (answer = <span class="dv">42</span>) { printf(<span class="st">&quot;I&#39;ve solved the answer! It&#39;s %d&quot;</span>, answer);}</code></pre></div>
<h2 id="undeclared-or-incorrectly-prototyped-functions">Undeclared or incorrectly prototyped functions</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">time_t start = time();</code></pre></div>
<p>The system function ‘time’ actually takes a parameter (a pointer to some memory that can receive the time_t structure). The compiler did not catch this error because the programmer did not provide a valid function prototype by including <code>time.h</code></p>
<h2 id="extra-semicolons">Extra Semicolons</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++) ; printf(<span class="st">&quot;I&#39;m printed once&quot;</span>);
<span class="kw">while</span>(x &lt; <span class="dv">10</span>); x++ ; <span class="co">// X is never incremented</span></code></pre></div>
<p>However, the following code is perfectly OK.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">5</span>; i++){
    printf(<span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, i);;;;;;;;;;;;;
}</code></pre></div>
<p>It is OK to have this kind of code, because the C language uses semicolons (;) to separate statements. If there is no statement in between semicolons, then there is nothing to do and the compiler moves on to the next statement</p>
<h1 id="other-gotchas">Other Gotchas</h1>
<h2 id="preprocessor">Preprocessor</h2>
<p>What is the preprocessor? It is an operation that the compiler performs <strong>before</strong> actually compiling the program. It is a copy and paste command. Meaning that if I do the following.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define MAX_LENGTH 10</span>
<span class="dt">char</span> buffer[MAX_LENGTH]</code></pre></div>
<p>After preprocessing, it’ll look like this.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> buffer[<span class="dv">10</span>]</code></pre></div>
<h2 id="c-preprocessor-macros-and-side-effects">C Preprocessor macros and side-effects</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define min(a,b) ((a)&lt;(b) ? (a) : (b))</span>
<span class="dt">int</span> x = <span class="dv">4</span>;
<span class="kw">if</span>(min(x++, <span class="dv">100</span>)) printf(<span class="st">&quot;%d is six&quot;</span>, x);</code></pre></div>
<p>Macros are simple text substitution so the above example expands to <code>x++ &lt; 100 ? x++ : 100</code> (parenthesis omitted for clarity)</p>
<h2 id="c-preprocessor-macros-and-precedence">C Preprocessor macros and precedence</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define min(a,b) a&lt;b ? a : b</span>
<span class="dt">int</span> x = <span class="dv">99</span>;
<span class="dt">int</span> r = <span class="dv">10</span> + min(<span class="dv">99</span>, <span class="dv">100</span>); <span class="co">// r is 100!</span></code></pre></div>
<p>Macros are simple text substitution so the above example expands to <code>10 + 99 &lt; 100 ? 99 : 100</code></p>
<h2 id="c-preprocessor-logical-gotcha">C Preprocessor logical gotcha</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#define ARRAY_LENGTH(A) (sizeof((A)) / sizeof((A)[0]))</span>
<span class="dt">int</span> static_array[<span class="dv">10</span>]; <span class="co">// ARRAY_LENGTH(static_array) = 10</span>
<span class="dt">int</span>* dynamic_array = malloc(<span class="dv">10</span>); <span class="co">// ARRAY_LENGTH(dynamic_array) = 2 or 1</span></code></pre></div>
<p>What is wrong with the macro? Well, it works if we have a static array like the first array because sizeof a static array returns the bytes that array takes up, and dividing it by the sizeof(an_element) would give you the number of entries. But if we use a pointer to a piece of memory, taking the sizeof the pointer and dividing it by the size of the first entry won’t always give us the size of the array.</p>
<h2 id="does-sizeof-do-anything">Does sizeof do anything?</h2>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> a = <span class="dv">0</span>;
size_t size = <span class="kw">sizeof</span>(a++);
printf(<span class="st">&quot;size: %lu, a: %d&quot;</span>, size, a);</code></pre></div>
<p>What does the code print out?</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">size: <span class="dv">4</span>, a: <span class="dv">0</span></code></pre></div>
<p>Because sizeof is not actually evaluated at runtime. The compiler assigns the type of all expressions and discards the extra results of the expression.</p>
<h1 id="strings-structs-and-gotchas">Strings, Structs, and Gotcha’s</h1>
<h1 id="so-whats-a-string">So what’s a string?</h1>
<div class="figure">
<img src="https://i.imgur.com/CgsxyZb.png" alt="String" />
<p class="caption">String</p>
</div>
<p>In C we have <a href="https://en.wikipedia.org/wiki/Null-terminated_string">Null Terminated</a> strings rather than <a href="https://en.wikipedia.org/wiki/String_(computer_science)#Length-prefixed">Length Prefixed</a> for historical reasons. What that means for your average everyday programming is that you need to remember the null character! A string in C is defined as a bunch of bytes until you reach ‘’ or the Null Byte.</p>
<h2 id="two-places-for-strings">Two places for strings</h2>
<p>Whenever you define a constant string (ie one in the form <code>char* str = constant</code>) That string is stored in the <em>data</em> or <em>code</em> segment that is <strong>read-only</strong> meaning that any attempt to modify the string will cause a segfault.</p>
<p>If one, however, <code>malloc</code>’s space, one can change that string to be whatever they want.</p>
<h2 id="memory-mismanagement">Memory Mismanagement</h2>
<p>One common gotcha is when you write the following</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* hello_string = malloc(<span class="dv">14</span>);
                       ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
<span class="co">// hello_string ----&gt; | g | a | r | b | a | g | e | g | a | r | b | a | g | e |</span>
                       ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾
hello_string = <span class="st">&quot;Hello Bhuvan!&quot;</span>;
<span class="co">// (constant string in the text segment)</span>
<span class="co">// hello_string ----&gt; [ &quot;H&quot; , &quot;e&quot; , &quot;l&quot; , &quot;l&quot; , &quot;o&quot; , &quot; &quot; , &quot;B&quot; , &quot;h&quot; , &quot;u&quot; , &quot;v&quot; , &quot;a&quot; , &quot;n&quot; , &quot;!&quot; , &quot;\0&quot; ]</span>
                       ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
<span class="co">// memory_leak -----&gt; | g | a | r | b | a | g | e | g | a | r | b | a | g | e |</span>
                       ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾
hello_string[<span class="dv">9</span>] = &#39;t&#39;; <span class="co">//segfault!!</span></code></pre></div>
<p>What did we do? We allocated space for 14 bytes, reassigned the pointer and successfully segfaulted! Remember to keep track of what your pointers are doing. What you probably wanted to do was use a <code>string.h</code> function <code>strcpy</code>.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">strcpy(hello_string, <span class="st">&quot;Hello Bhuvan!&quot;</span>);</code></pre></div>
<h2 id="remember-the-null-byte">Remember the NULL byte!</h2>
<p>Forgetting to NULL terminate a string is a big affect on the strings! Bounds checking is important. The heart bleed bug mentioned earlier in the wiki book is partially because of this.</p>
<h2 id="where-can-i-find-an-in-depth-and-assignment-comprehensive-explanation-of-all-of-these-functions">Where can I find an In-Depth and Assignment-Comprehensive explanation of all of these functions?</h2>
<p><a href="https://linux.die.net/man/3/string">Right Here!</a></p>
<h2 id="string-informationcomparison-strlen-strcmp">String Information/Comparison: strlen strcmp</h2>
<p><code>int strlen(const char s)</code> returns the length of the string not including the null byte</p>
<p><code>int strcmp(const char s1, const char s2)</code> returns an integer determining the lexicographic order of the strings. If s1 where to come before s2 in a dictionary, then a -1 is returned. If the two strings are equal, then 0. Else, 1.</p>
<p>With most of these functions, they expect the strings to be readable and not NULL but there is undefined behavior when you pass them NULL.</p>
<h2 id="string-alteration-strcpy-strcat-strdup">String Alteration: strcpy strcat strdup</h2>
<p><code>char strcpy(char dest, const char src)</code> Copies the string at <code>src</code> to <code>dest</code>. <strong>assumes dest has enough space for src</strong></p>
<p><code>char strcat(char dest, const char src)</code> Concatenates the string at <code>src</code> to the end of destination. <strong>This function assumes that there is enough space for <code>src</code> at the end of destination including the NULL byte</strong></p>
<p><code>char strdup(const char dest)</code> Returns a <code>malloc</code>’ed copy of the string.</p>
<h2 id="string-search-strchr-strstr">String Search: strchr strstr</h2>
<p><code>char strchr(const char haystack, int needle)</code> Returns a pointer to the first occurrence of <code>needle</code> in the <code>haystack</code>. If none found, <code>NULL</code> is returned.</p>
<p><code>char strstr(const char haystack, const char needle)</code> Same as above but this time a string!</p>
<h2 id="string-tokenize-strtok">String Tokenize: strtok</h2>
<p>A dangerous but useful function strtok takes a string and tokenizes it. Meaning that it will transform the strings into separate strings. This function has a lot of specs so please read the man pages a contrived example is below.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="dt">int</span> main(){
    <span class="dt">char</span>* upped = strdup(<span class="st">&quot;strtok,is,tricky,!!&quot;</span>);
    <span class="dt">char</span>* start = strtok(upped, <span class="st">&quot;,&quot;</span>);
    <span class="kw">do</span>{
        printf(<span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span>, start);
    }<span class="kw">while</span>((start = strtok(NULL, <span class="st">&quot;,&quot;</span>)));
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p><strong>Output</strong></p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">strtok
is
tricky
!!</code></pre></div>
<p>What happens when I change <code>upped</code> like this?</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>* upped = strdup(<span class="st">&quot;strtok,is,tricky,,,!!&quot;</span>);</code></pre></div>
<h2 id="memory-movement-memcpy-and-memmove">Memory Movement: memcpy and memmove</h2>
<p>Why are <code>memcpy</code> and <code>memmove</code> both in <code>&lt;string.h&gt;</code>? Because strings are essentially raw memory with a null byte at the end of them!</p>
<p><code>void memcpy(void dest, const void src, size_t n)</code> moves <code>n</code> bytes starting at <code>src</code> to <code>dest</code>. <strong>Be careful</strong>, there is undefined behavior when the memory regions overlap. This is one of the classic works on my machine examples because many times valgrind won’t be able to pick it up because it will look like it works on your machine. When the autograder hits, fail. Consider the safer version which is.</p>
<p><code>void memmove(void dest, const void src, size_t n)</code> does the same thing as above, but if the memory regions overlap then it is guaranteed that all the bytes will get copied over correctly.</p>
<h1 id="so-whats-a-struct">So what’s a struct?</h1>
<p>In low-level terms, a struct is just a piece of contiguous memory, nothing more. Just like an array, a struct has enough space to keep all of its members. But unlike an array, it can store different types. Consider the contact struct declared above</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> contact {
    <span class="dt">char</span> firstname[<span class="dv">20</span>];
    <span class="dt">char</span> lastname[<span class="dv">20</span>];
    <span class="dt">unsigned</span> <span class="dt">int</span> phone;
};

<span class="kw">struct</span> contact bhuvan;</code></pre></div>
<p><strong>Brief aside</strong></p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">/* a lot of times we will do the following typdef</span>
<span class="co"> so we can just write contact contact1 */</span>

<span class="kw">typedef</span> <span class="kw">struct</span> contact contact;
contact bhuvan;

<span class="co">/* You can also declare the struct like this to get</span>
<span class="co"> it done in one statement */</span>
<span class="kw">typedef</span> <span class="kw">struct</span> optional_name {
    ...
} contact;</code></pre></div>
<p>If you compile the code without any optimizations and reordering, you can expect the addresses of each of the variables to look like this.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">&amp;bhuvan           <span class="co">// 0x100</span>
&amp;bhuvan.firstname <span class="co">// 0x100 = 0x100+0x00</span>
&amp;bhuvan.lastname  <span class="co">// 0x114 = 0x100+0x14</span>
&amp;bhuvan.phone     <span class="co">// 0x128 = 0x100+0x28</span></code></pre></div>
<p>Because all your compiler does is say ‘hey reserve this much space, and I will go and calculate the offsets of whatever variables you want to write to’.</p>
<h2 id="what-do-these-offsets-mean">What do these offsets mean?</h2>
<p>The offsets are where the variable starts at. The phone variables starts at the <code>0x128</code>th bytes and continues for sizeof(int) bytes, but not always. <strong>Offsets don’t determine where the variable ends though</strong>. Consider the following hack that you see in a lot of kernel code.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">
<span class="kw">typedef</span> <span class="kw">struct</span> {
    <span class="dt">int</span> length;
    <span class="dt">char</span> c_str[<span class="dv">0</span>];
} string;

<span class="dt">const</span> <span class="dt">char</span>* to_convert = <span class="st">&quot;bhuvan&quot;</span>;
<span class="dt">int</span> length = strlen(to_convert);

<span class="co">// Let&#39;s convert to a c string</span>
string* bhuvan_name;
bhuvan_name = malloc(<span class="kw">sizeof</span>(string) + length<span class="dv">+1</span>);
<span class="co">/*</span>
<span class="co">Currently, our memory looks like this with junk in those black spaces</span>
<span class="co">                ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___</span>
<span class="co"> bhuvan_name = |   |   |   |   |   |   |   |   |   |   |   |</span>
<span class="co">                ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾</span>
<span class="co">*/</span>


bhuvan_name-&gt;length = length;
<span class="co">/*</span>
<span class="co">This writes the following values to the first four bytes</span>
<span class="co">The rest is still garbage</span>
<span class="co">                ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___</span>
<span class="co"> bhuvan_name = | 0 | 0 | 0 | 6 |   |   |   |   |   |   |   |</span>
<span class="co">                ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾</span>
<span class="co">*/</span>


strcpy(bhuvan_name-&gt;c_str, to_convert);
<span class="co">/*</span>
<span class="co">Now our string is filled in correctly at the end of the struct</span>

<span class="co">                ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ____</span>
<span class="co"> bhuvan_name = | 0 | 0 | 0 | 6 | b | h | u | v | a | n | \0 |</span>
<span class="co">                ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾‾</span>
<span class="co">*/</span>

strcmp(bhuvan_name-&gt;c_str, <span class="st">&quot;bhuvan&quot;</span>) == <span class="dv">0</span> <span class="co">//The strings are equal!</span></code></pre></div>
<h2 id="but-not-all-structs-are-perfect">But not all structs are perfect</h2>
<p>Structs may require something called <a href="http://www.catb.org/esr/structure-packing/">padding</a> (tutorial). **We do not expect you to pack structs in this course, just know that it is there This is because in the early days (and even now) when you have to an address from memory you have to do it in 32bit or 64bit blocks. This also meant that you could only request addresses that were multiples of that. Meaning that</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> picture{
    <span class="dt">int</span> height;
    pixel** data;
    <span class="dt">int</span> width;
    <span class="dt">char</span>* enconding;
}
<span class="co">// You think picture looks like this</span>
           height      data         width     encoding
           ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
picture = |       |               |       |               |
           ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾</code></pre></div>
<p>Would conceptually look like this</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> picture{
    <span class="dt">int</span> height;
    <span class="dt">char</span> slop1[<span class="dv">4</span>];
    pixel** data;
    <span class="dt">int</span> width;
    <span class="dt">char</span> slop2[<span class="dv">4</span>];
    <span class="dt">char</span>* enconding;
}
           height   slop1       data        width   slop2  encoding
           ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
picture = |       |       |               |       |       |               |
           ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾</code></pre></div>
<p>This is on a 64-bit system. This is not always the case because sometimes your processor supports unaligned accesses. What does this mean? Well there are two options you can set an attribute</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> __attribute__((packed, aligned(<span class="dv">4</span>))) picture{
    <span class="dt">int</span> height;
    pixel** data;
    <span class="dt">int</span> width;
    <span class="dt">char</span>* enconding;
}
<span class="co">// Will look like this</span>
           height       data        width     encoding
           ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
picture = |       |               |       |               |
           ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾</code></pre></div>
<p>But now, every time I want to access <code>data</code> or <code>encoding</code>, I have to do two memory accesses. The other thing you can do is reorder the struct, although this is not always possible</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> picture{
    <span class="dt">int</span> height;
    <span class="dt">int</span> width;
    pixel** data;
    <span class="dt">char</span>* enconding;
}
<span class="co">// You think picture looks like this</span>
           height   width        data         encoding
           ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___ ___
picture = |       |       |               |               |
           ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾ ‾‾‾</code></pre></div>
<h1 id="the-hitchhikers-guide-to-debugging-c-programs">The Hitchhiker’s Guide to Debugging C Programs</h1>
<p>This is going to be a massive guide to helping you debug your C programs. There are different levels that you can check errors and we will be going through most of them. Feel free to add anything that you found helpful in debugging C programs including but not limited to, debugger usage, recognizing common error types, gotchas, and effective googling tips.</p>
<h1 id="in-code-debugging">In-Code Debugging</h1>
<h2 id="clean-code">Clean code</h2>
<p>Make your code modular using helper functions. If there is a repeated task (getting the pointers to contiguous blocks in the malloc MP, for example), make them helper functions. And make sure each function does one thing very well, so that you don’t have to debug twice.</p>
<p>Let’s say that we are doing selection sort by finding the minimum element each iteration like so,</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> selection_sort(<span class="dt">int</span> *a, <span class="dt">long</span> len){
     <span class="kw">for</span>(<span class="dt">long</span> i = len<span class="dv">-1</span>; i &gt; <span class="dv">0</span>; --i){
         <span class="dt">long</span> max_index = i;
         <span class="kw">for</span>(<span class="dt">long</span> j = len<span class="dv">-1</span>; j &gt;= <span class="dv">0</span>; --j){
             <span class="kw">if</span>(a[max_index] &lt; a[j]){
                  max_index = j;
             }
         }
         <span class="dt">int</span> temp = a[i];
         a[i] = a[max_index];
         a[max_index] = temp;
     }

}</code></pre></div>
<p>Many can see the bug in the code, but it can help to refactor the above method into</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">long</span> max_index(<span class="dt">int</span> *a, <span class="dt">long</span> start, <span class="dt">long</span> end);
<span class="dt">void</span> swap(<span class="dt">int</span> *a, <span class="dt">long</span> idx1, <span class="dt">long</span> idx2);
<span class="dt">void</span> selection_sort(<span class="dt">int</span> *a, <span class="dt">long</span> len);</code></pre></div>
<p>And the error is specifically in one function.</p>
<p>In the end, we are not a class about refactoring/debugging your code. In fact, most systems code is so atrocious that you don’t want to read it. But for the sake of debugging, it may benefit you in the long run to adopt some practices.</p>
<h2 id="asserts">Asserts!</h2>
<p>Use assertions to make sure your code works up to a certain point – and importantly, to make sure you don’t break it later. For example, if your data structure is a doubly linked list, you can do something like <code>assert(node-&gt;size == node-&gt;next-&gt;prev-&gt;size)</code> to assert that the next node has a pointer to the current node. You can also check the pointer is pointing to an expected range of memory address, not null, -&gt;size is reasonable etc. The <code>NDEBUG</code> macro will disable all assertions, so don’t forget to set that once you finish debugging. http://www.cplusplus.com/reference/cassert/assert/</p>
<p>Here’s a quick example with assert. Let’s say that I’m writing code using memcpy</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">assert(!(src &lt; dest+n &amp;&amp; dest &lt; src+n)); <span class="co">//Checks overlap</span>
memcpy(dest, src, n);</code></pre></div>
<p>This check can be turned off at compile time, but will save you <strong>tons</strong> of trouble debugging!</p>
<h2 id="printfs">printfs</h2>
<p>When all else fails, print like crazy! Each of your functions should have an idea of what it is going to do (ie find_min better find the minimum element). You want to test that each of your functions is doing what it set out to do and see exactly where your code breaks. In the case with race conditions, tsan may be able to help, but having each thread print out data at certain times could help you identify the race condition.</p>
<h1 id="valgrind">Valgrind</h1>
<p>Valgrind is a suite of tools designed to provide debugging and profiling tools to make your programs more correct and detect some runtime issues. The most used of these tools is Memcheck, which can detect many memory-related errors that are common in C and C++ programs and that can lead to crashes and unpredictable behaviour (for example, unfreed memory buffers).</p>
<p>To run Valgrind on your program:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">valgrind --leak-check=yes myprogram arg1 arg2</code></pre></div>
<p>or</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">valgrind ./myprogram</code></pre></div>
<p>Arguments are optional and the default tool that will run is Memcheck. The output will be presented in form of number of allocations, number of freed allocations, and the number of errors.</p>
<p><strong>Example</strong></p>
<div class="figure">
<img src="https://i.imgur.com/ZdBWDvh.png" alt="Valgrind Example" />
<p class="caption">Valgrind Example</p>
</div>
<p>Here’s an example to help you interpret the above results. Suppose we have a simple program like this:</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">  <span class="ot">#include &lt;stdlib.h&gt;</span>

  <span class="dt">void</span> dummy_function()
  {
     <span class="dt">int</span>* x = malloc(<span class="dv">10</span> * <span class="kw">sizeof</span>(<span class="dt">int</span>));
     x[<span class="dv">10</span>] = <span class="dv">0</span>;        <span class="co">// error 1:as you can see here we write to an out of bound memory address</span>
  }                    <span class="co">// error 2: memory leak the allocated x not freed</span>

  <span class="dt">int</span> main(<span class="dt">void</span>)
  {
     dummy_function();
     <span class="kw">return</span> <span class="dv">0</span>;
  }</code></pre></div>
<p>Let’s see what Valgrind will output (this program compiles and run with no errors).</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">==<span class="dv">29515</span>== Memcheck, a memory error detector
==<span class="dv">29515</span>== Copyright (C) <span class="dv">2002-2015</span>, and GNU GPL&#39;d, by Julian Seward et al.
==<span class="dv">29515</span>== Using Valgrind<span class="fl">-3.11.0</span> and LibVEX; rerun with -h <span class="kw">for</span> copyright info
==<span class="dv">29515</span>== Command: ./a
==<span class="dv">29515</span>== 
==<span class="dv">29515</span>== Invalid write of size <span class="dv">4</span>
==<span class="dv">29515</span>==    at <span class="bn">0x400544</span>: dummy_function (in /home/rafi/projects/exocpp/a)
==<span class="dv">29515</span>==    by <span class="bn">0x40055A</span>: main (in /home/rafi/projects/exocpp/a)
==<span class="dv">29515</span>==  Address <span class="bn">0x5203068</span> is <span class="dv">0</span> bytes after a block of size <span class="dv">40</span> alloc&#39;d
==<span class="dv">29515</span>==    at <span class="bn">0x4C2DB8F</span>: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==<span class="dv">29515</span>==    by <span class="bn">0x400537</span>: dummy_function (in /home/rafi/projects/exocpp/a)
==<span class="dv">29515</span>==    by <span class="bn">0x40055A</span>: main (in /home/rafi/projects/exocpp/a)
==<span class="dv">29515</span>== 
==<span class="dv">29515</span>== 
==<span class="dv">29515</span>== HEAP SUMMARY:
==<span class="dv">29515</span>==     in use at exit: <span class="dv">40</span> bytes in <span class="dv">1</span> blocks
==<span class="dv">29515</span>==   total heap usage: <span class="dv">1</span> allocs, <span class="dv">0</span> frees, <span class="dv">40</span> bytes allocated
==<span class="dv">29515</span>== 
==<span class="dv">29515</span>== LEAK SUMMARY:
==<span class="dv">29515</span>==    definitely lost: <span class="dv">40</span> bytes in <span class="dv">1</span> blocks
==<span class="dv">29515</span>==    indirectly lost: <span class="dv">0</span> bytes in <span class="dv">0</span> blocks
==<span class="dv">29515</span>==      possibly lost: <span class="dv">0</span> bytes in <span class="dv">0</span> blocks
==<span class="dv">29515</span>==    still reachable: <span class="dv">0</span> bytes in <span class="dv">0</span> blocks
==<span class="dv">29515</span>==         suppressed: <span class="dv">0</span> bytes in <span class="dv">0</span> blocks
==<span class="dv">29515</span>== Rerun with --leak-check=full to see details of leaked memory
==<span class="dv">29515</span>== 
==<span class="dv">29515</span>== For counts of detected and suppressed errors, rerun with: -v
==<span class="dv">29515</span>== ERROR SUMMARY: <span class="dv">1</span> errors from <span class="dv">1</span> contexts (suppressed: <span class="dv">0</span> from <span class="dv">0</span>)</code></pre></div>
<p><strong>Invalid write</strong>: It detected our heap block overrun (writing outside of allocated block)</p>
<p><strong>Definitely lost</strong>: Memory leak—you probably forgot to free a memory block</p>
<p>Valgrind is a very effective tool to check for errors at runtime. C is very special when it comes to such behavior, so after compiling your program you can use Valgrind to fix errors that your compiler may not catch and that usually happen when your program is running.</p>
<p>For more information, you can refer to the <a href="http://valgrind.org/docs/manual/quick-start.html">official website</a>.</p>
<h1 id="tsan">Tsan</h1>
<p>ThreadSanitizer is a tool from Google, built into clang (and gcc), to help you detect race conditions in your code. For more information about the tool, see the Github wiki.</p>
<p>Note that running with tsan will slow your code down a bit.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;pthread.h&gt;</span>
<span class="ot">#include &lt;stdio.h&gt;</span>

<span class="dt">int</span> Global;

<span class="dt">void</span> *Thread1(<span class="dt">void</span> *x) {
    Global++;
    <span class="kw">return</span> NULL;
}

<span class="dt">int</span> main() {
    pthread_t t[<span class="dv">2</span>];
    pthread_create(&amp;t[<span class="dv">0</span>], NULL, Thread1, NULL);
    Global = <span class="dv">100</span>;
    pthread_join(t[<span class="dv">0</span>], NULL);
}
<span class="co">// compile with gcc -fsanitize=thread -pie -fPIC -ltsan -g simple_race.c</span></code></pre></div>
<p>We can see that there is a race condition on the variable <code>Global</code>. Both the main thread and the thread created with pthread_create will try to change the value at the same time. But, does ThreadSantizer catch it?</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">$ ./a.out
==================
WARNING: ThreadSanitizer: data race (pid=<span class="dv">28888</span>)
  Read of size <span class="dv">4</span> at <span class="bn">0x7f73ed91c078</span> by thread T1:
    <span class="er">#0 Thread1 /home/zmick2/simple_race.c:7 (exe+0x000000000a50)</span>
    <span class="er">#1  :0 (libtsan.so.0+0x00000001b459)</span>

  Previous write of size <span class="dv">4</span> at <span class="bn">0x7f73ed91c078</span> by main thread:
    <span class="er">#0 main /home/zmick2/simple_race.c:14 (exe+0x000000000ac8)</span>

  Thread T1 (tid=<span class="dv">28889</span>, running) created by main thread at:
    <span class="er">#0  :0 (libtsan.so.0+0x00000001f6ab)</span>
    <span class="er">#1 main /home/zmick2/simple_race.c:13 (exe+0x000000000ab8)</span>

SUMMARY: ThreadSanitizer: data race /home/zmick2/simple_race.c:<span class="dv">7</span> Thread1
==================
ThreadSanitizer: reported <span class="dv">1</span> warnings</code></pre></div>
<p>If we compiled with the debug flag, then it would give us the variable name as well.</p>
<h1 id="gdb">GDB</h1>
<p>Introduction: http://www.cs.cmu.edu/~gilpin/tutorial/</p>
<h4 id="setting-breakpoints-programmatically">Setting breakpoints programmatically</h4>
<p>A very useful trick when debugging complex C programs with GDB is setting breakpoints in the source code.</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main() {
    <span class="dt">int</span> val = <span class="dv">1</span>;
    val = <span class="dv">42</span>;
    asm(<span class="st">&quot;int $3&quot;</span>); <span class="co">// set a breakpoint here</span>
    val = <span class="dv">7</span>;
}</code></pre></div>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">$ gcc main.c -g -o main &amp;&amp; ./main
(gdb) r
[...]
Program received signal SIGTRAP, Trace/breakpoint trap.
main () at main.c:<span class="dv">6</span>
<span class="dv">6</span>     val = <span class="dv">7</span>;
(gdb) p val
$<span class="dv">1</span> = <span class="dv">42</span></code></pre></div>
<h4 id="checking-memory-content">Checking memory content</h4>
<p>http://www.delorie.com/gnu/docs/gdb/gdb_56.html</p>
<p>For example,</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main() {
    <span class="dt">char</span> bad_string[<span class="dv">3</span>] = {&#39;C&#39;, &#39;a&#39;, &#39;t&#39;};
    printf(<span class="st">&quot;%s&quot;</span>, bad_string);
}</code></pre></div>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">$ gcc main.c -g -o main &amp;&amp; ./main
$ Cat ZVQ� $</code></pre></div>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c">(gdb) l
<span class="dv">1</span> #include &lt;stdio.h&gt;
<span class="dv">2</span> <span class="dt">int</span> main() {
<span class="dv">3</span>     <span class="dt">char</span> bad_string[<span class="dv">3</span>] = {&#39;C&#39;, &#39;a&#39;, &#39;t&#39;};
<span class="dv">4</span>     printf(<span class="st">&quot;%s&quot;</span>, bad_string);
<span class="dv">5</span> }
(gdb) b <span class="dv">4</span>
Breakpoint <span class="dv">1</span> at <span class="bn">0x100000f57</span>: file main.c, line <span class="dv">4</span>.
(gdb) r
[...]
Breakpoint <span class="dv">1</span>, main () at main.c:<span class="dv">4</span>
<span class="dv">4</span>     printf(<span class="st">&quot;%s&quot;</span>, bad_string);
(gdb) x/16xb bad_string
<span class="bn">0x7fff5fbff9cd</span>: <span class="bn">0x63</span>  <span class="bn">0x61</span>  <span class="bn">0x74</span>  <span class="bn">0xe0</span>  <span class="bn">0xf9</span>  <span class="bn">0xbf</span>  <span class="bn">0x5f</span>  <span class="bn">0xff</span>
<span class="bn">0x7fff5fbff9d5</span>: <span class="bn">0x7f</span>  <span class="bn">0x00</span>  <span class="bn">0x00</span>  <span class="bn">0xfd</span>  <span class="bn">0xb5</span>  <span class="bn">0x23</span>  <span class="bn">0x89</span>  <span class="bn">0xff</span>

(gdb)</code></pre></div>
<p>Here, by using the <code>x</code> command with parameters <code>16xb</code>, we can see that starting at memory address <code>0x7fff5fbff9c</code> (value of <code>bad_string</code>), printf would actually see the following sequence of bytes as a string because we provided a malformed string without a null terminator.</p>
<p><code>0x43 0x61 0x74 0xe0 0xf9 0xbf 0x5f 0xff 0x7f 0x00</code></p>
<h1 id="topics">Topics</h1>
<ul>
<li><p>C Strings representation</p></li>
<li><p>C Strings as pointers</p></li>
<li><p>char p<span>[</span><span>]</span>vs char* p</p></li>
<li><p>Simple C string functions (strcmp, strcat, strcpy)</p></li>
<li><p>sizeof char</p></li>
<li><p>sizeof x vs x*</p></li>
<li><p>Heap memory lifetime</p></li>
<li><p>Calls to heap allocation</p></li>
<li><p>Deferencing pointers</p></li>
<li><p>Address-of operator</p></li>
<li><p>Pointer arithmetic</p></li>
<li><p>String duplication</p></li>
<li><p>String truncation</p></li>
<li><p>double-free error</p></li>
<li><p>String literals</p></li>
<li><p>Print formatting.</p></li>
<li><p>memory out of bounds errors</p></li>
<li><p>static memory</p></li>
<li><p>fileio POSIX vs. C library</p></li>
<li><p>C io fprintf and printf</p></li>
<li><p>POSIX file IO (read, write, open)</p></li>
<li><p>Buffering of stdout</p></li>
</ul>
<h1 id="questionsexercises">Questions/Exercises</h1>
<ul>
<li><p>What does the following print out</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> main(){
fprintf(stderr, <span class="st">&quot;Hello &quot;</span>);
fprintf(stdout, <span class="st">&quot;It&#39;s a small &quot;</span>);
fprintf(stderr, <span class="st">&quot;World</span><span class="ch">\n</span><span class="st">&quot;</span>);
fprintf(stdout, <span class="st">&quot;place</span><span class="ch">\n</span><span class="st">&quot;</span>);
<span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div></li>
<li><p>What are the differences between the following two declarations? What does <code>sizeof</code> return for one of them?</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> str1[] = <span class="st">&quot;bhuvan&quot;</span>;
<span class="dt">char</span> *str2 = <span class="st">&quot;another one&quot;</span>;</code></pre></div></li>
<li><p>What is a string in c?</p></li>
<li><p>Code up a simple <code>my_strcmp</code>. How about <code>my_strcat</code>, <code>my_strcpy</code>, or <code>my_strdup</code>? Bonus: Code the functions while only going through the strings <em>once</em>.</p></li>
<li><p>What should the following usually return?</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> *ptr;
<span class="kw">sizeof</span>(ptr);
<span class="kw">sizeof</span>(*ptr);</code></pre></div></li>
<li><p>What is <code>malloc</code>? How is it different than <code>calloc</code>. Once memory is <code>malloc</code>ed how can I use <code>realloc</code>?</p></li>
<li><p>What is the <code>&amp;</code> operator? How about <code>*</code>?</p></li>
<li><p>Pointer Arithmetic. Assume the following addresses. What are the following shifts?</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span>** ptr = malloc(<span class="dv">10</span>); <span class="co">//0x100</span>
ptr[<span class="dv">0</span>] = malloc(<span class="dv">20</span>); <span class="co">//0x200</span>
ptr[<span class="dv">1</span>] = malloc(<span class="dv">20</span>); <span class="co">//0x300</span></code></pre></div>
<ul>
<li><p><code>ptr + 2</code></p></li>
<li><p><code>ptr + 4</code></p></li>
<li><p><code>ptr[0] + 4</code></p></li>
<li><p><code>ptr[1] + 2000</code></p></li>
<li><p><code>*((int)(ptr + 1)) + 3</code></p></li>
</ul></li>
<li><p>How do we prevent double free errors?</p></li>
<li><p>What is the printf specifier to print a string, <code>int</code>, or <code>char</code>?</p></li>
<li><p>Is the following code valid? If so, why? Where is <code>output</code> located?</p>
<div class="sourceCode" language="C"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">char</span> *foo(<span class="dt">int</span> var){
<span class="dt">static</span> <span class="dt">char</span> output[<span class="dv">20</span>];
snprintf(output, <span class="dv">20</span>, <span class="st">&quot;%d&quot;</span>, var);
<span class="kw">return</span> output;
}</code></pre></div></li>
<li><p>Write a function that accepts a string and opens that file prints out the file 40 bytes at a time but every other print reverses the string (try using POSIX API for this).</p></li>
<li><p>What are some differences between the POSIX filedescriptor model and C’s <code>FILE*</code> (ie what function calls are used and which is buffered)? Does POSIX use C’s <code>FILE*</code> internally or vice versa?</p></li>
</ul>
</body>
</html>
