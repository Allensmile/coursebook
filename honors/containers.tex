\section{Containerization}
As we enter an era of unprecedented scale with around 20 billion devices
connected to the internet in 2018, we need technologies that help us develop and
maintain software capable of scaling upwards. Additionally, as software increases
in complexity, and designing secure software becomes harder, we find that we
have new constraints imposed on us as we develop applications. As if that wasn't
enough, efforts to simplify software distribution and development, like package
manager systems can often lead to headaches of their own, leading to broken
packages, dependencies that are impossible to resolve and other such
environmental nightmares that have become all to common today. While these seem
like disjoint problems at first, all of these and more can be solved by throwing
\keyword{containerization} at the problem.

\subsection{What is a container?}
You can think of a container as something that is almost like a virtual machine.
In some senses, containers are to virtual machines as threads are to processes.
A container is a lightweight environment that shares resources and a kernel with
a host machine, while isolating itself from other containers or processes on the
host. You may have encountered containers while working with technologies such
as \keyword{Docker}, perhaps the most well-known implementation of containers
out there.

\subsection{Linux Namespaces}

\subsection{Building a container from scratch}

\subsection{Containers in the wild: Software distribution is a Snap}
