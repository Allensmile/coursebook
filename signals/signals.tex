\section{Wait Macros}\label{wait-macros}

\subsection{Can I find out the exit value of my
child?}\label{can-i-find-out-the-exit-value-of-my-child}

You can find the lowest 8 bits of the child's exit value (the return
value of \texttt{main()} or value included in \texttt{exit()}): Use the
``Wait macros'' - typically you will use ``WIFEXITED'' and
``WEXITSTATUS'' . See \texttt{wait}/\texttt{waitpid} man page for more
information).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{status;}
\NormalTok{pid_t child = fork();}
\KeywordTok{if} \NormalTok{(child == -}\DecValTok{1}\NormalTok{) }\KeywordTok{return} \DecValTok{1}\NormalTok{; }\CommentTok{//Failed}
\KeywordTok{if} \NormalTok{(child > }\DecValTok{0}\NormalTok{) \{ }\CommentTok{/* I am the parent - wait for the child to finish */}
  \NormalTok{pid_t pid = waitpid(child, &status, }\DecValTok{0}\NormalTok{);}
  \KeywordTok{if} \NormalTok{(pid != -}\DecValTok{1} \NormalTok{&& WIFEXITED(status)) \{}
     \DataTypeTok{int} \NormalTok{low8bits = WEXITSTATUS(status);}
     \NormalTok{printf(}\StringTok{"Process %d returned %d"} \NormalTok{, pid, low8bits);}
  \NormalTok{\}}
\NormalTok{\} }\KeywordTok{else} \NormalTok{\{ }\CommentTok{/* I am the child */}
 \CommentTok{// do something interesting}
  \NormalTok{execl(}\StringTok{"/bin/ls"}\NormalTok{, }\StringTok{"/bin/ls"}\NormalTok{, }\StringTok{"."}\NormalTok{, (}\DataTypeTok{char} \NormalTok{*) NULL); }\CommentTok{// "ls ."}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

A process can only have 256 return values, the rest of the bits are
informational.

\subsection{Bit Shifting}\label{bit-shifting}

Note there is no need to memorize this, this is just a high level
overview of how information is stored inside the status variables

From Android source code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* If WIFEXITED(STATUS), the low-order 8 bits of the status. */}

\OtherTok{#define __WEXITSTATUS(status) (((status) & 0xff00) >> 8)}

\CommentTok{/* If WIFSIGNALED(STATUS), the terminating signal. */}

\OtherTok{#define __WTERMSIG(status) ((status) & 0x7f)}

\CommentTok{/* If WIFSTOPPED(STATUS), the signal that stopped the child. */}

\OtherTok{#define __WSTOPSIG(status) __WEXITSTATUS(status)}

\CommentTok{/* Nonzero if STATUS indicates normal termination. */}

\OtherTok{#define __WIFEXITED(status) (__WTERMSIG(status) == 0)}
\end{Highlighting}
\end{Shaded}

The kernel has an internal way of keeping track of signaled, exited, or
stopped. That API is abstracted so that that the kernel developers are
free to change at will.

\subsection{Being careful.}\label{being-careful.}

Remember that the the macros only make sense if the precondition is met.
Meaning that a process' exit status won't be defined if the process is
signaled. The macros will not do the checking for you, so it's up to the
programming to make sure the logic checks out.

\section{Signals}\label{signals}

\subsection{What's a signal?}\label{whats-a-signal}

A signal is a construct provided to us by the kernel. It allows one
process to asynchronously send a signal (think a message) to another
process. If that process wants to accept the signal, it can, and then,
for most signals, can decide what to do with that signal. Here is a
short list (non comprehensive) of signals.

\begin{longtable}[c]{@{}lll@{}}
\toprule
\begin{minipage}[b]{0.12\columnwidth}\raggedright\strut
Name
\strut\end{minipage} &
\begin{minipage}[b]{0.44\columnwidth}\raggedright\strut
Default Action
\strut\end{minipage} &
\begin{minipage}[b]{0.35\columnwidth}\raggedright\strut
Usual Use Case
\strut\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
SIGINT
\strut\end{minipage} &
\begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
Terminate Process (Can be caught)
\strut\end{minipage} &
\begin{minipage}[t]{0.35\columnwidth}\raggedright\strut
Tell the process to stop nicely
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
SIGQUIT
\strut\end{minipage} &
\begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
Terminate Process (Can be caught)
\strut\end{minipage} &
\begin{minipage}[t]{0.35\columnwidth}\raggedright\strut
Tells the process to stop harshly
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
SIGSTOP
\strut\end{minipage} &
\begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
Stop Process (Cannot be caught)
\strut\end{minipage} &
\begin{minipage}[t]{0.35\columnwidth}\raggedright\strut
Stops the process to be continued
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
SIGCONT
\strut\end{minipage} &
\begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
Continues a Process
\strut\end{minipage} &
\begin{minipage}[t]{0.35\columnwidth}\raggedright\strut
Continues to run the process
\strut\end{minipage}\tabularnewline
\begin{minipage}[t]{0.12\columnwidth}\raggedright\strut
SIGKILL
\strut\end{minipage} &
\begin{minipage}[t]{0.44\columnwidth}\raggedright\strut
Terminate Process (Cannot be caught)
\strut\end{minipage} &
\begin{minipage}[t]{0.35\columnwidth}\raggedright\strut
You want your process gone
\strut\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\subsection{When are signals
generated?}\label{when-are-signals-generated}

\begin{itemize}
\tightlist
\item
  When the user sends a signal. For example, you are at the terminal,
  and you send \texttt{CTRL-C}
\item
  When a system event happens. For example, you get a \texttt{SIGCHILD}
  after forking to notice when one of your children have exited.
\item
  When another program sends it. For example, when you execute
  \texttt{kill\ -9\ PID}, it sends \texttt{SIGKILL}
\item
  When an appropriate hardware interrupt is triggered. For example, if
  you access a page that you aren't supposed to, the hardware generates
  a segfault interrupt which gets intercepted by the kernel. The kernel
  finds the process that caused this and sends a software interrupt
  signal \texttt{SIGSEGV}.
\end{itemize}

\subsection{Can I pause my child?}\label{can-i-pause-my-child}

Yes ! You can temporarily pause a running process by sending it a
SIGSTOP signal. If it succeeds it will freeze a process; i.e.~the
process will not be allocated any more CPU time.

To allow a process to resume execution send it the SIGCONT signal.

For example, Here's program that slowly prints a dot every second, up to
59 dots.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <unistd.h>}
\OtherTok{#include <stdio.h>}
\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{printf(}\StringTok{"My pid is %d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, getpid() );}
  \DataTypeTok{int} \NormalTok{i = }\DecValTok{60}\NormalTok{;}
  \KeywordTok{while}\NormalTok{(--i) \{ }
    \NormalTok{write(}\DecValTok{1}\NormalTok{, }\StringTok{"."}\NormalTok{,}\DecValTok{1}\NormalTok{);}
    \NormalTok{sleep(}\DecValTok{1}\NormalTok{);}
  \NormalTok{\}}
  \NormalTok{write(}\DecValTok{1}\NormalTok{, }\StringTok{"Done!"}\NormalTok{,}\DecValTok{5}\NormalTok{);}
  \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We will first start the process in the background (notice the \& at the
end). Then send it a signal from the shell process by using the kill
command.

\begin{verbatim}
>./program &
My pid is 403
...
>kill -SIGSTOP 403
>kill -SIGCONT 403
\end{verbatim}

\subsection{How do I kill/stop/suspend my child from
C?}\label{how-do-i-killstopsuspend-my-child-from-c}

In C, send a signal to the child using \texttt{kill} POSIX call,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kill(child, SIGUSR1); }\CommentTok{// Send a user-defined signal}
\NormalTok{kill(child, SIGSTOP); }\CommentTok{// Stop the child process (the child cannot prevent this)}
\NormalTok{kill(child, SIGTERM); }\CommentTok{// Terminate the child process (the child can prevent this)}
\NormalTok{kill(child, SIGINT); }\CommentTok{// Equivalent to CTRL-C (by default closes the process)}
\end{Highlighting}
\end{Shaded}

As we saw above there is also a kill command available in the shell
e.g.~get a list of running processes and then terminate process 45 and
process 46

\begin{verbatim}
ps
kill -l 
kill -9 45
kill -s TERM 46
\end{verbatim}

\subsection{\texorpdfstring{How can I detect ``CTRL-C'' and clean up
gracefully?}{How can I detect CTRL-C and clean up gracefully?}}\label{how-can-i-detect-ctrl-c-and-clean-up-gracefully}

We will return to signals later on - this is just a short introduction.
On a Linux system, see \texttt{man\ -s7\ signal} if you are interested
in finding out more (for example a list of system and library calls that
are async-signal-safe).

There are strict limitations on the executable code inside a signal
handler. Most library and system calls are not `async-signal-safe' -
they may not be used inside a signal handler because they are not
re-entrant safe. In a single-threaded program, signal handling
momentarily interrupts the program execution to execute the signal
handler code instead. Suppose your original program was interrupted
while executing the library code of \texttt{malloc} ; the memory
structures used by malloc will not be in a consistent state. Calling
\texttt{printf} (which uses \texttt{malloc}) as part of the signal
handler is unsafe and will result in ``undefined behavior'' i.e.~it is
no longer a useful,predictable program. In practice your program might
crash, compute or generate incorrect results or stop functioning
(``deadlock''), depending on exactly what your program was executing
when it was interrupted to execute the signal handler code.

One common use of signal handlers is to set a boolean flag that is
occasionally polled (read) as part of the normal running of the program.
For example,

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{pleaseStop ; }\CommentTok{// See notes on why "volatile sig_atomic_t" is better}

\DataTypeTok{void} \NormalTok{handle_sigint(}\DataTypeTok{int} \NormalTok{signal) \{}
  \NormalTok{pleaseStop = }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{int} \NormalTok{main() \{}
  \NormalTok{signal(SIGINT, handle_sigint);}
  \NormalTok{pleaseStop = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{while} \NormalTok{( ! pleaseStop) \{ }
     \CommentTok{/* application logic here */} 
   \NormalTok{\}}
  \CommentTok{/* cleanup code here */}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The above code might appear to be correct on paper. However, we need to
provide a hint to the compiler and to the CPU core that will execute the
\texttt{main()} loop. We need to prevent a compiler optimization: The
expression \texttt{!\ pleaseStop} appears to be a loop invariant
i.e.~true forever, so can be simplified to \texttt{true}. Secondly, we
need to ensure that the value of \texttt{pleaseStop} is not cached using
a CPU register and instead always read from and written to main memory.
The \texttt{sig\_atomic\_t} type implies that all the bits of the
variable can be read or modified as an ``atomic operation'' - a single
uninterruptable operation. It is impossible to read a value that is
composed of some new bit values and old bit values.

By specifying \texttt{pleaseStop} with the correct type
\texttt{volatile\ sig\_atomic\_t} we can write portable code where the
main loop will be exited after the signal handler returns. The
\texttt{sig\_atomic\_t} type can be as large as an \texttt{int} on most
modern platforms but on embedded systems can be as small as a
\texttt{char} and only able to represent (-127 to 127) values.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{volatile} \NormalTok{sig_atomic_t pleaseStop;}
\end{Highlighting}
\end{Shaded}

Two examples of this pattern can be found in ``COMP'' a terminal based
1Hz 4bit computer
(https://github.com/gto76/comp-cpp/blob/1bf9a77eaf8f57f7358a316e5bbada97f2dc8987/src/output.c\#L121).
Two boolean flags are used. One to mark the delivery of \texttt{SIGINT}
(CTRL-C), and gracefully shutdown the program, and the other to mark
\texttt{SIGWINCH} signal to detect terminal resize and redraw the entire
display.

\section{Signals In Depth}\label{signals-in-depth}

\subsection{How can I learn more about
signals?}\label{how-can-i-learn-more-about-signals}

The linux man pages discusses signal system calls in section 2. There is
also a longer article in section 7 (though not in OSX/BSD):

\begin{verbatim}
man -s7 signal
\end{verbatim}

\subsection{Signal Terminology}\label{signal-terminology}

\begin{itemize}
\tightlist
\item
  Generated - The signal is being created in the kernel by the kill
  system call.
\item
  Pending - Not delivered yet but soon to be delivered
\item
  Blocked - Not delivered because no signal disposition lets the signal
  be delivered
\item
  Delivered - Delivered to the process, the action described is being
  taken
\item
  Caught - When the process stops a signal from destroying it and does
  something else with it instead
\end{itemize}

\subsection{What is a process's signal
disposition?}\label{what-is-a-processs-signal-disposition}

For each process, each signal has a disposition which means what action
will occur when a signal is delivered to the process. For example, the
default disposition SIGINT is to terminate it. The signal disposition
can be changed by calling signal() (which is simple but not portable as
there are subtle variations in its implementation on different POSIX
architectures and also not recommended for multi-threaded programs) or
\texttt{sigaction} (discussed later). You can imagine the processes'
disposition to all possible signals as a table of function pointers
entries (one for each possible signal).

The default disposition for signals can be to ignore the signal, stop
the process, continue a stopped process, terminate the process, or
terminate the process and also dump a `core' file. Note a core file is a
representation of the processes' memory state that can be inspected
using a debugger.

\subsection{Can multiple signals be
queued?}\label{can-multiple-signals-be-queued}

No - however it is possible to have signals that are in a pending state.
If a signal is pending, it means it has not yet been delivered to the
process. The most common reason for a signal to be pending is that the
process (or thread) has currently blocked that particular signal.

If a particular signal, e.g.~SIGINT, is pending then it is not possible
to queue up the same signal again.

It \emph{is} possible to have more than one signal of a different type
in a pending state. For example SIGINT and SIGTERM signals may be
pending (i.e.~not yet delivered to the target process)

\subsection{How do I block signals?}\label{how-do-i-block-signals}

Signals can be blocked (meaning they will stay in the pending state) by
setting the process signal mask or, when you are writing a
multi-threaded program, the thread signal mask.

\section{Disposition in
Threads/Children}\label{disposition-in-threadschildren}

\subsection{What happens when creating a new
thread?}\label{what-happens-when-creating-a-new-thread}

The new thread inherits a copy of the calling thread's mask

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pthread_sigmask( ... ); }\CommentTok{// set my mask to block delivery of some signals}
\NormalTok{pthread_create( ... ); }\CommentTok{// new thread will start with a copy of the same mask}
\end{Highlighting}
\end{Shaded}

\subsection{What happens when forking?}\label{what-happens-when-forking}

The child process inherits a copy of the parent's signal dispositions.
In other words, if you have installed a SIGINT handler before forking,
then the child process will also call the handler if a SIGINT is
delivered to the child.

Note pending signals for the child are \emph{not} inherited during
forking.

\subsection{What happens during exec ?}\label{what-happens-during-exec}

Both the signal mask and the signal disposition carries over to the
exec-ed program.
\href{Source}{https://www.gnu.org/software/libc/manual/html\_node/Executing-a-File.html\#Executing-a-File}
Pending signals are preserved as well. Signal handlers are reset,
because the original handler code has disappeared along with the old
process.

\subsection{What happens during fork ?}\label{what-happens-during-fork}

The child process inherits a copy of the parent process's signal
disposition and a copy of the parent's signal mask.

For example if \texttt{SIGINT} is blocked in the parent it will be
blocked in the child too. For example if the parent installed a handler
(call-back function) for SIG-INT then the child will also perform the
same behavior.

Pending signals however are not inherited by the child.

\subsection{How do I block signals in a single-threaded
program?}\label{how-do-i-block-signals-in-a-single-threaded-program}

Use \texttt{sigprocmask}! With sigprocmask you can set the new mask, add
new signals to be blocked to the process mask, and unblock currently
blocked signals. You can also determine the existing mask (and use it
for later) by passing in a non-null value for oldset.

\begin{verbatim}
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`
\end{verbatim}

From the Linux man page of sigprocmask,

\begin{verbatim}
SIG_BLOCK: The set of blocked signals is the union of the current set and the set argument.
SIG_UNBLOCK: The signals in set are removed from the current set of blocked signals. It is permissible to attempt to unblock a signal which is not blocked.
SIG_SETMASK: The set of blocked signals is set to the argument set.
\end{verbatim}

The sigset type behaves as a bitmap, except functions are used rather
than explicitly setting and unsetting bits using \& and \textbar{}.

It is a common error to forget to initialize the signal set before
modifying one bit. For example,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sigset_t set, oldset;}
\NormalTok{sigaddset(&set, SIGINT); }\CommentTok{// Ooops!}
\NormalTok{sigprocmask(SIG_SETMASK, &set, &oldset)}
\end{Highlighting}
\end{Shaded}

Correct code initializes the set to be all on or all off. For example,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sigfillset(&set); }\CommentTok{// all signals}
\NormalTok{sigprocmask(SIG_SETMASK, &set, NULL); }\CommentTok{// Block all the signals!}
\CommentTok{// (Actually SIGKILL or SIGSTOP cannot be blocked...)}

\NormalTok{sigemptyset(&set); }\CommentTok{// no signals }
\NormalTok{sigprocmask(SIG_SETMASK, &set, NULL); }\CommentTok{// set the mask to be empty again}
\end{Highlighting}
\end{Shaded}

\subsection{How do I block signals in a multi-threaded
program?}\label{how-do-i-block-signals-in-a-multi-threaded-program}

Blocking signals is similar in multi-threaded programs to
single-threaded programs: * Use pthread\_sigmask instead of sigprocmask
* Block a signal in all threads to prevent its asynchronous delivery

The easiest method to ensure a signal is blocked in all threads is to
set the signal mask in the main thread before new threads are created

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sigemptyset(&set);}
\NormalTok{sigaddset(&set, SIGQUIT);}
\NormalTok{sigaddset(&set, SIGINT);}
\NormalTok{pthread_sigmask(SIG_BLOCK, &set, NULL);}

\CommentTok{// this thread and the new thread will block SIGQUIT and SIGINT}
\NormalTok{pthread_create(&thread_id, NULL, myfunc, funcparam);}
\end{Highlighting}
\end{Shaded}

Just as we saw with sigprocmask, pthread\_sigmask includes a `how'
parameter that defines how the signal set is to be used:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pthread_sigmask(SIG_SETMASK, &set, NULL) - replace the thread's mask with given signal set}
\NormalTok{pthread_sigmask(SIG_BLOCK, &set, NULL) - add the signal set to the thread's mask}
\NormalTok{pthread_sigmask(SIG_UNBLOCK, &set, NULL) - remove the signal set from the thread's mask}
\end{Highlighting}
\end{Shaded}

\subsection{How are pending signals delivered in a multi-threaded
program?}\label{how-are-pending-signals-delivered-in-a-multi-threaded-program}

A signal is delivered to any signal thread that is not blocking that
signal.

If the two or more threads can receive the signal then which thread will
be interrupted is arbitrary!

\subsection{How do I send a signal to a process from the
shell?}\label{how-do-i-send-a-signal-to-a-process-from-the-shell}

You already know one way to send a \texttt{SIG\_INT} just type
\texttt{CTRL-C} From the shell you can use \texttt{kill} (if you know
the process id) and \texttt{killall} (if you know the process name)

\begin{verbatim}
# First let's use ps and grep to find the process we want to send a signal to
$ ps au | grep myprogram
angrave  4409   0.0  0.0  2434892    512 s004  R+    2:42PM   0:00.00 myprogram 1 2 3

#Send SIGINT signal to process 4409 (equivalent of `CTRL-C`)
$ kill -SIGINT 4409

#Send SIGKILL (terminate the process)
$ kill -SIGKILL 4409
$ kill -9 4409
\end{verbatim}

\texttt{killall} is similar except that it matches by program name. The
next two example, sends a \texttt{SIGINT} and then \texttt{SIGKILL} to
terminate the processes that are running \texttt{myprogram}

\begin{verbatim}
# Send SIGINT (SIGINT can be ignored)
$ killall -SIGINT myprogram

# SIGKILL (-9) cannot be ignored! 
$ killall -9 myprogram
\end{verbatim}

\subsection{How do I send a signal to a process from the running C
program?}\label{how-do-i-send-a-signal-to-a-process-from-the-running-c-program}

Use \texttt{raise} or \texttt{kill}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{raise(}\DataTypeTok{int} \NormalTok{sig); }\CommentTok{// Send a signal to myself!}
\DataTypeTok{int} \NormalTok{kill(pid_t pid, }\DataTypeTok{int} \NormalTok{sig); }\CommentTok{// Send a signal to another process}
\end{Highlighting}
\end{Shaded}

For non-root processes, signals can only be sent to processes of the
same user i.e.~you cant just SIGKILL my processes! See kill(2) i.e.~man
-s2 for more details.

\subsection{How do I send a signal to a specific
thread?}\label{how-do-i-send-a-signal-to-a-specific-thread}

Use \texttt{pthread\_kill}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{pthread_kill(pthread_t thread, }\DataTypeTok{int} \NormalTok{sig)}
\end{Highlighting}
\end{Shaded}

In the example below, the newly created thread executing \texttt{func}
will be interrupted by \texttt{SIGINT}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pthread_create(&tid, NULL, func, args);}
\NormalTok{pthread_kill(tid, SIGINT);}
\NormalTok{pthread_kill(pthread_self(), SIGKILL); }\CommentTok{// send SIGKILL to myself}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Will
\texttt{pthread\_kill(\ threadid,\ SIGKILL)} kill the process or
thread?}{Will pthread\_kill( threadid, SIGKILL) kill the process or thread?}}\label{will-pthreadux5fkill-threadid-sigkill-kill-the-process-or-thread}

It will kill the entire process. Though individual threads can set a
signal mask, the signal disposition (the table of handlers/action
performed for each signal) is \emph{per-proces}s not \emph{per-thread}.
This means \texttt{sigaction} can be called from any thread because you
will be setting a signal handler for all threads in the process.

\subsection{How do I catch (handle) a signal
?}\label{how-do-i-catch-handle-a-signal}

You can choose a handle pending signals asynchronously or synchronously.

Install a signal handler to asynchronously handle signals use
\texttt{sigaction} (or, for simple examples, \texttt{signal} ).

To synchronously catch a pending signal use \texttt{sigwait} (which
blocks until a signal is delivered) or \texttt{signalfd} (which also
blocks and provides a file descriptor that can be \texttt{read()} to
retrieve pending signals).

See \texttt{Signals,\ Part\ 4} for an example of using \texttt{sigwait}

\subsection{\texorpdfstring{How and why do I use \texttt{sigaction}
?}{How and why do I use sigaction ?}}\label{how-and-why-do-i-use-sigaction}

You should use \texttt{sigaction} instead of \texttt{signal} because it
has better defined semantics. \texttt{signal} on different operating
system does different things which is \textbf{bad} \texttt{sigaction} is
more portable and is better defined for threads if need be.

To change the ``signal disposition'' of a process - i.e.~what happens
when a signal is delivered to your process - use \texttt{sigaction}

You can use system call \texttt{sigaction} to set the current handler
for a signal or read the current signal handler for a particular signal.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{sigaction(}\DataTypeTok{int} \NormalTok{signum, }\DataTypeTok{const} \KeywordTok{struct} \NormalTok{sigaction *act, }\KeywordTok{struct} \NormalTok{sigaction *oldact);}
\end{Highlighting}
\end{Shaded}

The sigaction struct includes two callback functions (we will only look
at the `handler' version), a signal mask and a flags field -

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{sigaction \{}
               \DataTypeTok{void}     \NormalTok{(*sa_handler)(}\DataTypeTok{int}\NormalTok{);}
               \DataTypeTok{void}     \NormalTok{(*sa_sigaction)(}\DataTypeTok{int}\NormalTok{, siginfo_t *, }\DataTypeTok{void} \NormalTok{*);}
               \NormalTok{sigset_t   sa_mask;}
               \DataTypeTok{int}        \NormalTok{sa_flags;}
\NormalTok{\}; }
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{How do I convert a \texttt{signal} call into
the equivalent \texttt{sigaction}
call?}{How do I convert a signal call into the equivalent sigaction call?}}\label{how-do-i-convert-a-signal-call-into-the-equivalent-sigaction-call}

Suppose you installed a signal handler for the alarm signal,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{signal(SIGALRM, myhandler);}
\end{Highlighting}
\end{Shaded}

The equivalent \texttt{sigaction} code is:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct} \NormalTok{sigaction sa; }
\NormalTok{sa.sa_handler = myhandler;}
\NormalTok{sigemptyset(&sa.sa_mask);}
\NormalTok{sa.sa_flags = }\DecValTok{0}\NormalTok{; }
\NormalTok{sigaction(SIGALRM, &sa, NULL)}
\end{Highlighting}
\end{Shaded}

However, we typically may also set the mask and the flags field. The
mask is a temporary signal mask used during the signal handler
execution. The SA\_RESTART flag will automatically restart some (but not
all) system calls that otherwise would have returned early (with EINTR
error). The latter means we can simplify the rest of code somewhat
because a restart loop may no longer be required.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sigfillset(&sa.sa_mask);}
\NormalTok{sa.sa_flags = SA_RESTART; }\CommentTok{/* Restart functions if  interrupted by handler */}     
\end{Highlighting}
\end{Shaded}

\subsection{How do I use sigwait?}\label{how-do-i-use-sigwait}

Sigwait can be used to read one pending signal at a time.
\texttt{sigwait} is used to synchronously wait for signals, rather than
handle them in a callback. A typical use of sigwait in a multi-threaded
program is shown below. Notice that the thread signal mask is set first
(and will be inherited by new threads). This prevents signals from being
\emph{delivered} so they will remain in a pending state until sigwait is
called. Also notice the same set sigset\_t variable is used by sigwait -
except rather than setting the set of blocked signals it is being used
as the set of signals that sigwait can catch and return.

One advantage of writing a custom signal handling thread (such as the
example below) rather than a callback function is that you can now use
many more C library and system functions that otherwise could not be
safely used in a signal handler because they are not async signal-safe.

Based on
\texttt{http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread\_sigmask.html}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{static} \NormalTok{sigset_t   signal_mask;  }\CommentTok{/* signals to block         */}

\DataTypeTok{int} \NormalTok{main (}\DataTypeTok{int} \NormalTok{argc, }\DataTypeTok{char} \NormalTok{*argv[])}
\NormalTok{\{}
    \NormalTok{pthread_t sig_thr_id;      }\CommentTok{/* signal handler thread ID */}
    \NormalTok{sigemptyset (&signal_mask);}
    \NormalTok{sigaddset (&signal_mask, SIGINT);}
    \NormalTok{sigaddset (&signal_mask, SIGTERM);}
    \NormalTok{pthread_sigmask (SIG_BLOCK, &signal_mask, NULL);}

    \CommentTok{/* New threads will inherit this thread's mask */}
    \NormalTok{pthread_create (&sig_thr_id, NULL, signal_thread, NULL);}

    \CommentTok{/* APPLICATION CODE */}
    \NormalTok{...}
\NormalTok{\}}

\DataTypeTok{void} \NormalTok{*signal_thread (}\DataTypeTok{void} \NormalTok{*arg)}
\NormalTok{\{}
    \DataTypeTok{int}       \NormalTok{sig_caught;    }\CommentTok{/* signal caught       */}

    \CommentTok{/* Use same mask as the set of signals that we'd like to know about! */}
    \NormalTok{sigwait(&signal_mask, &sig_caught);}
    \KeywordTok{switch} \NormalTok{(sig_caught)}
    \NormalTok{\{}
    \KeywordTok{case} \NormalTok{SIGINT:     }\CommentTok{/* process SIGINT  */}
        \NormalTok{...}
        \KeywordTok{break}\NormalTok{;}
    \KeywordTok{case} \NormalTok{SIGTERM:    }\CommentTok{/* process SIGTERM */}
        \NormalTok{...}
        \KeywordTok{break}\NormalTok{;}
    \KeywordTok{default}\NormalTok{:         }\CommentTok{/* should normally not happen */}
        \NormalTok{fprintf (stderr, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{Unexpected signal %d}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, sig_caught);}
        \KeywordTok{break}\NormalTok{;}
    \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{Topics}\label{topics}

\begin{itemize}
\tightlist
\item
  Signals
\item
  Signal Handler Safe
\item
  Signal Disposition
\item
  Signal States
\item
  Pending Signals when Forking/Exec
\item
  Signal Disposition when Forking/Exec
\item
  Raising Signals in C
\item
  Raising Signals in a multithreaded program
\end{itemize}

\section{Questions}\label{questions}

\begin{itemize}
\tightlist
\item
  What is a signal?
\item
  How are signals served under UNIX? (Bonus: How about Windows?)
\item
  What does it mean that a function is signal handler safe
\item
  What is a process Signal Disposition?
\item
  How do I change the signal disposition in a single threaded program?
  How about multithreaded?
\item
  Why sigaction vs signal?
\item
  How do I asynchronously and synchronously catch a signal?
\item
  What happens to pending signals after I fork? Exec?
\item
  What happens to my signal disposition after I fork? Exec?
\end{itemize}
